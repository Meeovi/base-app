"use client";import{AlreadyActiveSubscriptionError as A}from"@polar-sh/sdk/models/errors/alreadyactivesubscriptionerror.js";import{HTTPValidationError as U}from"@polar-sh/sdk/models/errors/httpvalidationerror";import{NotOpenCheckout as V}from"@polar-sh/sdk/models/errors/notopencheckout.js";import{PaymentError as q}from"@polar-sh/sdk/models/errors/paymenterror.js";import{PaymentNotReady as N}from"@polar-sh/sdk/models/errors/paymentnotready.js";import{createContext as J,useCallback as F,useContext as Q,useState as S}from"react";import{useForm as X}from"react-hook-form";var g=(c,u,a=1,m)=>{c.forEach(t=>{let e=t.loc.slice(a);m&&m.includes(e[0])&&(e=e.slice(1));for(let n=0;n<e.length&&!(!Number.isInteger(e[n])&&(e[n]=e[n].replace(/_([a-z])/g,d=>d[1].toUpperCase()),e[n]==="customFieldData"));n++);u(e.join("."),{type:t.type,message:t.msg})})};import{PolarCore as B}from"@polar-sh/sdk/core";import{checkoutsClientConfirm as K}from"@polar-sh/sdk/funcs/checkoutsClientConfirm";import{checkoutsClientGet as T}from"@polar-sh/sdk/funcs/checkoutsClientGet";import{checkoutsClientUpdate as O}from"@polar-sh/sdk/funcs/checkoutsClientUpdate";import{createContext as H,useCallback as v,useContext as L,useEffect as j,useMemo as G,useState as M}from"react";import{jsx as z}from"react/jsx-runtime";var W=()=>{throw new Error("You forgot to wrap your component in <CheckoutProvider>.")},x=H(W),Y=({clientSecret:c,serverURL:u,server:a,children:m})=>{let t=G(()=>new B({server:a,serverURL:u}),[a,u]),[e,n]=M(null);j(()=>{T(t,{clientSecret:c}).then(({ok:l,value:r,error:C})=>{if(l)n(r);else throw C})},[t,c]);let d=v(async()=>{let l=await T(t,{clientSecret:c});return l.ok&&n(l.value),l},[t,c]),k=v(async l=>{let r=await O(t,{clientSecret:c,checkoutUpdatePublic:l});return r.ok&&n(r.value),r},[t,c]),h=v(async l=>{let r=await K(t,{clientSecret:c,checkoutConfirmStripe:l});return r.ok&&n(r.value),r},[t,c]);return e?z(x.Provider,{value:{checkout:e,refresh:d,update:k,confirm:h,client:t},children:m}):null},w=()=>L(x);import{jsx as oe}from"react/jsx-runtime";var Z=()=>{throw new Error("You forgot to wrap your component in <CheckoutFormProvider>.")},R=J(Z),$=({children:c})=>{let{checkout:u,update:a,confirm:m}=w(),[t,e]=S(!1),[n,d]=S(),[k,h]=S(!1),l=X({defaultValues:{...u,customerBillingAddress:u.customerBillingAddress,discountCode:u.discount?u.discount.code:void 0},shouldUnregister:!0}),{setError:r}=l,C=F(async i=>{h(!0);let{ok:p,value:f,error:o}=await a(i).finally(()=>{h(!1)});if(p)return f;throw o instanceof U?g(o.detail||[],r):(o instanceof A||o instanceof V||o instanceof q||o instanceof N)&&r("root",{message:o.detail}),o},[a,r]),P=F(async i=>{let{ok:p,value:f,error:o}=await m(i);if(p)return f;throw o instanceof U?g(o.detail||[],r):(o instanceof A||o instanceof V||o instanceof q||o instanceof N)&&r("root",{message:o.detail}),o},[m,r]),_=F(async(i,p,f)=>{if(e(!0),!u.isPaymentFormRequired){d("Processing order...");try{return await P(i)}catch(s){throw s}finally{e(!1)}}if(!p||!f)throw e(!1),new Error("Stripe elements not provided");d("Processing payment");let{error:o}=await f.submit();if(o)throw o.type!=="validation_error"&&r("root",{message:o.message}),e(!1),new Error(o.message);let E,y;try{let s=await p.createConfirmationToken({elements:f,params:{payment_method_data:{billing_details:{name:i.customerName,email:i.customerEmail,address:{line1:i.customerBillingAddress?.line1||null,line2:i.customerBillingAddress?.line2||null,postal_code:i.customerBillingAddress?.postalCode||null,city:i.customerBillingAddress?.city||null,state:i.customerBillingAddress?.state||null,country:i.customerBillingAddress?.country||null},phone:null}}}});E=s.confirmationToken,y=s.error}catch(s){throw e(!1),s}if(!E||y)throw r("root",{message:y?.message||"Failed to create confirmation token, please try again later."}),e(!1),new Error("Failed to create confirmation token, please try again later.");let b;try{b=await P({...i,confirmationTokenId:E.id})}catch(s){throw e(!1),s}d("Payment successful! Getting your products ready...");let{intent_status:D,intent_client_secret:I}=b.paymentProcessorMetadata;if(D==="requires_action"){let{error:s}=await p.handleNextAction({clientSecret:I});if(s)throw e(!1),r("root",{message:s.message}),new Error(s.message)}return e(!1),b},[u,r,P]);return oe(R.Provider,{value:{checkout:u,form:l,update:C,confirm:_,loading:t,loadingLabel:n,isUpdatePending:k},children:c})},ee=()=>Q(R);export{x as CheckoutContext,R as CheckoutFormContext,$ as CheckoutFormProvider,Y as CheckoutProvider,w as useCheckout,ee as useCheckoutForm};
