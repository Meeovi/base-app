// src/webhooks/webhooks.ts
var handleWebhookPayload = async (payload, { webhookSecret, entitlements, onPayload, ...eventHandlers }) => {
  const promises = [];
  if (onPayload) {
    promises.push(onPayload(payload));
  }
  switch (payload.type) {
    case "checkout.created":
      if (eventHandlers.onCheckoutCreated) {
        promises.push(eventHandlers.onCheckoutCreated(payload));
      }
      break;
    case "checkout.updated":
      if (eventHandlers.onCheckoutUpdated) {
        promises.push(eventHandlers.onCheckoutUpdated(payload));
      }
      break;
    case "order.created":
      if (eventHandlers.onOrderCreated) {
        promises.push(eventHandlers.onOrderCreated(payload));
      }
      break;
    case "order.updated":
      if (eventHandlers.onOrderUpdated) {
        promises.push(eventHandlers.onOrderUpdated(payload));
      }
      break;
    case "order.paid":
      if (eventHandlers.onOrderPaid) {
        promises.push(eventHandlers.onOrderPaid(payload));
      }
      break;
    case "subscription.created":
      if (eventHandlers.onSubscriptionCreated) {
        promises.push(eventHandlers.onSubscriptionCreated(payload));
      }
      break;
    case "subscription.updated":
      if (eventHandlers.onSubscriptionUpdated) {
        promises.push(eventHandlers.onSubscriptionUpdated(payload));
      }
      break;
    case "subscription.active":
      if (eventHandlers.onSubscriptionActive) {
        promises.push(eventHandlers.onSubscriptionActive(payload));
      }
      break;
    case "subscription.canceled":
      if (eventHandlers.onSubscriptionCanceled) {
        promises.push(eventHandlers.onSubscriptionCanceled(payload));
      }
      break;
    case "subscription.uncanceled":
      if (eventHandlers.onSubscriptionUncanceled) {
        promises.push(eventHandlers.onSubscriptionUncanceled(payload));
      }
      break;
    case "subscription.revoked":
      if (eventHandlers.onSubscriptionRevoked) {
        promises.push(eventHandlers.onSubscriptionRevoked(payload));
      }
      break;
    case "product.created":
      if (eventHandlers.onProductCreated) {
        promises.push(eventHandlers.onProductCreated(payload));
      }
      break;
    case "product.updated":
      if (eventHandlers.onProductUpdated) {
        promises.push(eventHandlers.onProductUpdated(payload));
      }
      break;
    case "organization.updated":
      if (eventHandlers.onOrganizationUpdated) {
        promises.push(eventHandlers.onOrganizationUpdated(payload));
      }
      break;
    case "benefit.created":
      if (eventHandlers.onBenefitCreated) {
        promises.push(eventHandlers.onBenefitCreated(payload));
      }
      break;
    case "benefit.updated":
      if (eventHandlers.onBenefitUpdated) {
        promises.push(eventHandlers.onBenefitUpdated(payload));
      }
      break;
    case "benefit_grant.created":
      if (eventHandlers.onBenefitGrantCreated) {
        promises.push(eventHandlers.onBenefitGrantCreated(payload));
      }
      break;
    case "benefit_grant.updated":
      if (eventHandlers.onBenefitGrantUpdated) {
        promises.push(eventHandlers.onBenefitGrantUpdated(payload));
      }
      break;
    case "benefit_grant.revoked":
      if (eventHandlers.onBenefitGrantRevoked) {
        promises.push(eventHandlers.onBenefitGrantRevoked(payload));
      }
      break;
    case "customer.created":
      if (eventHandlers.onCustomerCreated) {
        promises.push(eventHandlers.onCustomerCreated(payload));
      }
      break;
    case "customer.updated":
      if (eventHandlers.onCustomerUpdated) {
        promises.push(eventHandlers.onCustomerUpdated(payload));
      }
      break;
    case "customer.deleted":
      if (eventHandlers.onCustomerDeleted) {
        promises.push(eventHandlers.onCustomerDeleted(payload));
      }
      break;
    case "customer.state_changed":
      if (eventHandlers.onCustomerStateChanged) {
        promises.push(eventHandlers.onCustomerStateChanged(payload));
      }
      break;
    case "order.refunded":
      if (eventHandlers.onOrderRefunded) {
        promises.push(eventHandlers.onOrderRefunded(payload));
      }
      break;
    case "refund.created":
      if (eventHandlers.onRefundCreated) {
        promises.push(eventHandlers.onRefundCreated(payload));
      }
      break;
    case "refund.updated":
      if (eventHandlers.onRefundUpdated) {
        promises.push(eventHandlers.onRefundUpdated(payload));
      }
      break;
  }
  switch (payload.type) {
    case "benefit_grant.created":
    case "benefit_grant.revoked":
      if (entitlements) {
        for (const handler of entitlements.handlers) {
          promises.push(handler(payload));
        }
      }
  }
  return Promise.all(promises);
};

// src/entitlement/entitlement.ts
var EntitlementStrategy = class {
  grantCallbacks = [];
  revokeCallbacks = [];
  grant(callback) {
    this.grantCallbacks.push(callback);
    return this;
  }
  revoke(callback) {
    this.revokeCallbacks.push(callback);
    return this;
  }
  handler(slug) {
    return async (payload) => {
      if (payload.data.benefit.description === slug) {
        switch (payload.type) {
          case "benefit_grant.created":
            await Promise.all(
              this.grantCallbacks.map(
                (callback) => callback({
                  customer: payload.data.customer,
                  properties: payload.data.properties,
                  payload
                })
              )
            );
            break;
          case "benefit_grant.revoked":
            await Promise.all(
              this.revokeCallbacks.map(
                (callback) => callback({
                  customer: payload.data.customer,
                  properties: payload.data.properties,
                  payload
                })
              )
            );
            break;
        }
      }
    };
  }
};
var Entitlements = class {
  static handlers = [];
  static use(slug, strategy) {
    this.handlers.push(strategy.handler(slug));
    return this;
  }
};
export {
  EntitlementStrategy,
  Entitlements,
  handleWebhookPayload
};
