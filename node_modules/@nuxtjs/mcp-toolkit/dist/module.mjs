import { execSync } from 'node:child_process';
import { logger, createResolver, defineNuxtModule, addComponent, addServerHandler, addServerTemplate, addServerImports } from '@nuxt/kit';
import { defu } from 'defu';
import { loadAllDefinitions } from '../dist/runtime/server/mcp/loaders/index.js';
import { defaultMcpConfig } from '../dist/runtime/server/mcp/config.js';
import { ROUTES } from '../dist/runtime/server/mcp/constants.js';
import { addDevToolsCustomTabs } from '../dist/runtime/server/mcp/devtools/index.js';

const name = "@nuxtjs/mcp-toolkit";
const version = "0.6.1";

const log = logger.withTag("@nuxtjs/mcp-toolkit");
const { resolve } = createResolver(import.meta.url);
const module$1 = defineNuxtModule({
  meta: {
    name,
    version,
    configKey: "mcp",
    docs: "https://mcp-toolkit.nuxt.dev/getting-started/installation",
    mcp: "https://mcp-toolkit.nuxt.dev/mcp"
  },
  defaults: defaultMcpConfig,
  async setup(options, nuxt) {
    if (nuxt.options.nitro.static || nuxt.options._generate) {
      log.warn("@nuxtjs/mcp-toolkit is not compatible with `nuxt generate` as it needs a server to run.");
      return;
    }
    const resolver = createResolver(import.meta.url);
    nuxt.options.runtimeConfig.mcp = defu(
      nuxt.options.runtimeConfig.mcp,
      {
        enabled: options.enabled,
        route: options.route,
        browserRedirect: options.browserRedirect,
        name: options.name,
        version: options.version,
        dir: options.dir
      }
    );
    if (!options.enabled) {
      return;
    }
    addComponent({
      name: "InstallButton",
      filePath: resolver.resolve("runtime/components/InstallButton.vue")
    });
    const mcpDir = options.dir ?? defaultMcpConfig.dir;
    const paths = {
      tools: [`${mcpDir}/tools`],
      resources: [`${mcpDir}/resources`],
      prompts: [`${mcpDir}/prompts`],
      handlers: [mcpDir]
    };
    let mcpSummary = null;
    nuxt.hook("modules:done", async () => {
      try {
        await nuxt.callHook("mcp:definitions:paths", paths);
        const result = await loadAllDefinitions(paths);
        if (result.handlers && result.handlers.count > 0) {
          addServerHandler({
            route: ROUTES.CUSTOM_HANDLER,
            handler: resolver.resolve("runtime/server/mcp/handler")
          });
        }
        if (result.total === 0) {
          log.warn("No MCP definitions found. Create tools, resources, or prompts in server/mcp/");
        } else {
          const summary = [];
          if (result.tools.count > 0) summary.push(`${result.tools.count} tool${result.tools.count > 1 ? "s" : ""}`);
          if (result.resources.count > 0) summary.push(`${result.resources.count} resource${result.resources.count > 1 ? "s" : ""}`);
          if (result.prompts.count > 0) summary.push(`${result.prompts.count} prompt${result.prompts.count > 1 ? "s" : ""}`);
          if (result.handlers.count > 0) summary.push(`${result.handlers.count} handler${result.handlers.count > 1 ? "s" : ""}`);
          mcpSummary = summary.join(", ");
        }
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log.error("Failed to initialize MCP server");
        log.error(`Error: ${errorMessage}`);
        throw error;
      }
    });
    nuxt.hook("listen", (_, listener) => {
      if (!mcpSummary) return;
      const ide = detectIDE();
      if (ide) {
        const ideName = ide === "cursor" ? "Cursor" : "VS Code";
        const mcpName = `local-${(options.name || "mcp-server").toLowerCase().replace(/\s+/g, "-")}`;
        const baseUrl = listener.url.replace(/\/$/, "");
        const deeplinkUrl = `${baseUrl}${options.route}/deeplink?ide=${ide}&name=${encodeURIComponent(mcpName)}`;
        log.success(`\`${options.route}\` enabled with ${mcpSummary} \xB7 ${terminalLink(`Install local MCP in ${ideName}`, deeplinkUrl)}`);
      } else {
        log.success(`\`${options.route}\` enabled with ${mcpSummary}`);
      }
    });
    nuxt.hook("prepare:types", ({ references }) => {
      references.push({
        path: resolver.resolve("runtime/server/types.server.d.ts")
      });
    });
    nuxt.options.nitro.typescript ??= {};
    nuxt.options.nitro.typescript.tsConfig ??= {};
    nuxt.options.nitro.typescript.tsConfig.include ??= [];
    nuxt.options.nitro.typescript.tsConfig.include.push(resolver.resolve("runtime/server/types.server.d.ts"));
    let isCloudflare = false;
    nuxt.hook("nitro:config", (nitroConfig) => {
      const preset = nitroConfig.preset || process.env.NITRO_PRESET || "";
      isCloudflare = preset.includes("cloudflare");
    });
    addServerTemplate({
      filename: "#nuxt-mcp/transport.mjs",
      getContents: () => {
        const provider = isCloudflare ? "cloudflare" : "node";
        return `export { default } from '${resolver.resolve(`runtime/server/mcp/providers/${provider}`)}'`;
      }
    });
    const mcpDefinitionsPath = resolver.resolve("runtime/server/mcp/definitions");
    addServerImports([
      "defineMcpTool",
      "defineMcpResource",
      "defineMcpPrompt",
      "defineMcpHandler",
      "textResult",
      "jsonResult",
      "errorResult",
      "imageResult"
    ].map((name2) => ({ name: name2, from: mcpDefinitionsPath })));
    addServerHandler({
      route: options.route,
      handler: resolver.resolve("runtime/server/mcp/handler")
    });
    addServerHandler({
      route: `${options.route}/deeplink`,
      handler: resolver.resolve("runtime/server/mcp/deeplink")
    });
    addServerHandler({
      route: `${options.route}/badge.svg`,
      handler: resolver.resolve("runtime/server/mcp/badge-image")
    });
    addDevToolsCustomTabs(nuxt, options);
  }
});
function terminalLink(text, url) {
  return `\x1B]8;;${url}\x07${text}\x1B]8;;\x07`;
}
function detectIDE() {
  const env = process.env;
  if (env.__CFBundleIdentifier === "com.todesktop.230313mzl4w4u92") return "cursor";
  if (env.__CFBundleIdentifier === "com.microsoft.VSCode") return "vscode";
  if (env.CURSOR_TRACE_ID) return "cursor";
  const ipc = env.VSCODE_IPC_HOOK || "";
  if (ipc.includes("/Cursor/")) return "cursor";
  if (ipc.includes("/Code/")) return "vscode";
  try {
    let pid = process.ppid;
    for (let i = 0; i < 10 && pid > 1; i++) {
      const name2 = execSync(`ps -o comm= -p ${pid}`, { stdio: ["pipe", "pipe", "ignore"] }).toString().toLowerCase();
      if (name2.includes("cursor")) return "cursor";
      if (name2.includes("code helper") || name2.includes("code.app")) return "vscode";
      pid = Number.parseInt(execSync(`ps -o ppid= -p ${pid}`, { stdio: ["pipe", "pipe", "ignore"] }).toString().trim());
    }
  } catch {
  }
  return null;
}

export { module$1 as default, resolve };
