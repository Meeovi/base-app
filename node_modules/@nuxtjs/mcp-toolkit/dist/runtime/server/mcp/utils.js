import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { sendRedirect, getHeader, defineEventHandler } from "h3";
import { registerToolFromDefinition, registerResourceFromDefinition, registerPromptFromDefinition } from "./definitions/index.js";
import handleMcpRequest from "#nuxt-mcp/transport.mjs";
export { createMcpTransportHandler } from "./providers/types.js";
function resolveConfig(config, event) {
  return typeof config === "function" ? config(event) : config;
}
export function createMcpServer(config) {
  const server = new McpServer({
    name: config.name,
    version: config.version
  });
  for (const tool of config.tools || []) {
    registerToolFromDefinition(server, tool);
  }
  for (const resource of config.resources || []) {
    registerResourceFromDefinition(server, resource);
  }
  for (const prompt of config.prompts || []) {
    registerPromptFromDefinition(server, prompt);
  }
  return server;
}
export function createMcpHandler(config) {
  return defineEventHandler(async (event) => {
    const resolvedConfig = resolveConfig(config, event);
    if (getHeader(event, "accept")?.includes("text/html")) {
      return sendRedirect(event, resolvedConfig.browserRedirect);
    }
    const handler = async () => {
      const server = createMcpServer(resolvedConfig);
      return handleMcpRequest(server, event);
    };
    if (resolvedConfig.middleware) {
      let nextCalled = false;
      let handlerResult;
      const next = async () => {
        nextCalled = true;
        handlerResult = await handler();
        return handlerResult;
      };
      const middlewareResult = await resolvedConfig.middleware(event, next);
      if (middlewareResult !== void 0) {
        return middlewareResult;
      }
      if (nextCalled) {
        return handlerResult;
      }
      return handler();
    }
    return handler();
  });
}
