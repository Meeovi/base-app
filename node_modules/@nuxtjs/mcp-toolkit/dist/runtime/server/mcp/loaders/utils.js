import { getLayerDirectories } from "@nuxt/kit";
import { resolve as resolvePath } from "pathe";
import { glob } from "tinyglobby";
const RESERVED_KEYWORDS = /* @__PURE__ */ new Set([
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "export",
  "extends",
  "finally",
  "for",
  "function",
  "if",
  "import",
  "in",
  "instanceof",
  "new",
  "return",
  "super",
  "switch",
  "this",
  "throw",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield",
  "enum",
  "implements",
  "interface",
  "let",
  "package",
  "private",
  "protected",
  "public",
  "static",
  "await",
  "abstract",
  "boolean",
  "byte",
  "char",
  "double",
  "final",
  "float",
  "goto",
  "int",
  "long",
  "native",
  "short",
  "synchronized",
  "transient",
  "volatile"
]);
export function createFilePatterns(paths, extensions = ["ts", "js", "mts", "mjs"]) {
  const layerDirectories = getLayerDirectories();
  return layerDirectories.flatMap(
    (layer) => paths.flatMap(
      (pathPattern) => extensions.map((ext) => resolvePath(layer.server, `${pathPattern}/*.${ext}`))
    )
  );
}
export function createLayerFilePatterns(layerServer, paths, extensions = ["ts", "js", "mts", "mjs"]) {
  return paths.flatMap(
    (pathPattern) => extensions.map((ext) => resolvePath(layerServer, `${pathPattern}/*.${ext}`))
  );
}
export function createExcludePatterns(paths, subdirs) {
  const layerDirectories = getLayerDirectories();
  return layerDirectories.flatMap(
    (layer) => paths.flatMap(
      (pathPattern) => subdirs.map((subdir) => resolvePath(layer.server, `${pathPattern}/${subdir}/**`))
    )
  );
}
export function toIdentifier(filename) {
  const id = filename.replace(/\.(ts|js|mts|mjs)$/, "").replace(/\W/g, "_");
  if (RESERVED_KEYWORDS.has(id)) {
    return `_${id}`;
  }
  return id;
}
export function createTemplateContent(type, entries) {
  const imports = entries.map(
    ([name, path]) => `import ${name.replace(/-/g, "_")} from '${path}'`
  ).join("\n");
  const enrichedExports = entries.map(([name, path]) => {
    const identifier = name.replace(/-/g, "_");
    const filename = path.split("/").pop();
    return `(function() {
  const def = ${identifier}
  return {
    ...def,
    _meta: {
      ...def._meta,
      filename: ${JSON.stringify(filename)}
    }
  }
})()`;
  }).join(",\n  ");
  return `${imports}

export const ${type} = [
  ${enrichedExports}
]
`;
}
export async function findIndexFile(paths, extensions = ["ts", "js", "mts", "mjs"]) {
  if (paths.length === 0) {
    return null;
  }
  const layerDirectories = getLayerDirectories();
  for (const layer of layerDirectories) {
    const indexPatterns = paths.flatMap(
      (pathPattern) => extensions.map((ext) => resolvePath(layer.server, `${pathPattern}/index.${ext}`))
    );
    const indexFiles = await glob(indexPatterns, {
      absolute: true,
      onlyFiles: true
    });
    if (indexFiles.length > 0) {
      return indexFiles[0];
    }
  }
  return null;
}
export async function loadDefinitionFiles(paths, options = {}) {
  if (paths.length === 0) {
    return { count: 0, files: [], overriddenCount: 0 };
  }
  const layerDirectories = getLayerDirectories();
  const reversedLayers = [...layerDirectories].reverse();
  const definitionsMap = /* @__PURE__ */ new Map();
  let overriddenCount = 0;
  for (const layer of reversedLayers) {
    const layerPatterns = createLayerFilePatterns(layer.server, paths);
    const layerFiles = await glob(layerPatterns, {
      absolute: true,
      onlyFiles: true,
      ignore: [...options.excludePatterns || [], "**/*.d.ts"]
    });
    const filteredFiles = options.filter ? layerFiles.filter(options.filter) : layerFiles;
    for (const filePath of filteredFiles) {
      const filename = filePath.split("/").pop();
      const identifier = toIdentifier(filename);
      if (definitionsMap.has(identifier)) {
        overriddenCount++;
      }
      definitionsMap.set(identifier, filePath);
    }
  }
  const total = definitionsMap.size;
  return {
    count: total,
    files: Array.from(definitionsMap.values()),
    overriddenCount
  };
}
