import { readFile } from "node:fs/promises";
import { resolve, extname } from "node:path";
import { pathToFileURL } from "node:url";
import { enrichNameTitle } from "./utils.js";
import { createCacheOptions, wrapWithCache } from "./cache.js";
function getMimeType(filePath) {
  const ext = extname(filePath).toLowerCase();
  switch (ext) {
    case ".md":
      return "text/markdown";
    case ".ts":
    case ".mts":
    case ".cts":
      return "text/typescript";
    case ".js":
    case ".mjs":
    case ".cjs":
      return "text/javascript";
    case ".json":
      return "application/json";
    case ".html":
      return "text/html";
    case ".css":
      return "text/css";
    case ".xml":
      return "text/xml";
    case ".csv":
      return "text/csv";
    case ".yaml":
    case ".yml":
      return "text/yaml";
    default:
      return "text/plain";
  }
}
export function registerResourceFromDefinition(server, resource) {
  const { name, title } = enrichNameTitle({
    name: resource.name,
    title: resource.title,
    _meta: resource._meta,
    type: "resource"
  });
  let uri = resource.uri;
  let handler = resource.handler;
  const metadata = {
    ...resource.metadata,
    title: resource.title || resource.metadata?.title || title,
    description: resource.description || resource.metadata?.description
  };
  if ("file" in resource && resource.file) {
    const filePath = resolve(process.cwd(), resource.file);
    if (!uri) {
      uri = pathToFileURL(filePath).toString();
    }
    if (!handler) {
      handler = async (requestUri) => {
        try {
          const content = await readFile(filePath, "utf-8");
          return {
            contents: [{
              uri: requestUri.toString(),
              mimeType: resource.metadata?.mimeType || getMimeType(filePath),
              text: content
            }]
          };
        } catch (error) {
          throw new Error(`Failed to read file ${filePath}: ${error instanceof Error ? error.message : String(error)}`);
        }
      };
    }
  }
  if (!uri) {
    throw new Error(`Resource ${name} is missing a URI`);
  }
  if (!handler) {
    throw new Error(`Resource ${name} is missing a handler`);
  }
  if (resource.cache !== void 0) {
    const defaultGetKey = (requestUri) => requestUri.pathname.replace(/\//g, "-").replace(/^-/, "");
    const cacheOptions = createCacheOptions(resource.cache, `mcp-resource:${name}`, defaultGetKey);
    handler = wrapWithCache(
      handler,
      cacheOptions
    );
  }
  if (typeof uri === "string") {
    return server.registerResource(
      name,
      uri,
      metadata,
      handler
    );
  } else {
    return server.registerResource(
      name,
      uri,
      metadata,
      handler
    );
  }
}
export function defineMcpResource(definition) {
  return definition;
}
