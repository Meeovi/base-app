const V = "app.grapesjs.com", k = "app-stage.grapesjs.com", X = "app2.grapesjs.com", j = "app-stage2.grapesjs.com", U = [
  V,
  X,
  k,
  j,
  "localhost",
  "127.0.0.1",
  ".local-credentialless.webcontainer.io",
  // For stackblitz.com demos
  ".local.webcontainer.io",
  // For stackblitz.com demos
  "-sandpack.codesandbox.io"
  // For Sandpack demos
], F = "license:check:start", q = "license:check:end", J = () => typeof window < "u", z = ({ isDev: e, isStage: a }) => `${e ? "" : `https://${a ? k : V}`}/api`, Q = () => {
  const e = J() && window.location.hostname;
  return !!e && (U.includes(e) || U.some((a) => e.endsWith(a)));
};
function Z(e) {
  return typeof e == "function";
}
async function ee({
  path: e,
  baseApiUrl: a,
  method: h = "GET",
  headers: l = {},
  params: f,
  body: s
}) {
  const n = `${a || z({ isDev: !1, isStage: !1 })}${e}`, m = {
    method: h,
    headers: {
      "Content-Type": "application/json",
      ...l
    }
  };
  s && (m.body = JSON.stringify(s));
  const d = f ? new URLSearchParams(f).toString() : "", t = d ? `?${d}` : "", c = await fetch(`${n}${t}`, m);
  if (!c.ok)
    throw new Error(`HTTP error! status: ${c.status}`);
  return c.json();
}
var L = /* @__PURE__ */ ((e) => (e.free = "free", e.startup = "startup", e.business = "business", e.enterprise = "enterprise", e))(L || {});
const W = {
  [L.free]: 0,
  [L.startup]: 10,
  [L.business]: 20,
  [L.enterprise]: 30
};
function te(e) {
  const a = e;
  return a.init = (h) => (l) => e(l, h), a;
}
const ne = (e) => /* @__PURE__ */ te(e);
async function se({
  editor: e,
  plan: a,
  pluginName: h,
  licenseKey: l,
  cleanup: f
}) {
  let s = "", o = !1;
  const n = Q(), m = (t) => {
    console.warn("Cleanup plugin:", h, "Reason:", t), f();
  }, d = (t = {}) => {
    var E;
    const { error: c, sdkLicense: p } = t, i = (E = t.plan) == null ? void 0 : E.category;
    if (!(p || t.license) || c)
      m(c || "Invalid license");
    else if (i) {
      const b = W[a], v = W[i];
      b > v && m({ pluginRequiredPlan: a, licensePlan: i });
    }
  };
  e.on(F, (t) => {
    s = t == null ? void 0 : t.baseApiUrl, o = !0;
  }), e.on(q, (t) => {
    d(t);
  }), setTimeout(async () => {
    if (!o) {
      if (n) return;
      if (l) {
        const t = await oe({ licenseKey: l, pluginName: h, baseApiUrl: s });
        t && d(t);
      } else
        m("The `licenseKey` option not provided");
    }
  }, 2e3);
}
async function oe(e) {
  const { licenseKey: a, pluginName: h, baseApiUrl: l } = e;
  try {
    return (await ee({
      baseApiUrl: l,
      path: `/sdk/${a || "na"}`,
      method: "POST",
      params: {
        d: window.location.hostname,
        pn: h
      }
    })).result || {};
  } catch (f) {
    return console.error("Error during SDK license check:", f), !1;
  }
}
const ce = "canvasAbsoluteMode", ie = L.startup, ae = (e, a, h) => {
  var d, t;
  const l = h.enableAbsolute ?? ((c) => c.hasAbsolute), s = (Array.isArray(a) ? a : a ? [a] : [...e.getSelectedAll()])[0], o = ((t = (d = s == null ? void 0 : s.delegate) == null ? void 0 : d.move) == null ? void 0 : t.call(d, s)) || s;
  if (!o) return;
  const n = o.getEl();
  return {
    result: Z(l) ? l({ component: o, hasAbsolute: !!n && getComputedStyle(n).position === "absolute" }) : !1,
    component: o,
    dmode: o.get("dmode")
  };
};
function B({
  guideMatched: e,
  canvasView: a
}) {
  var P;
  const h = e.guide.x === void 0 ? "y" : "x";
  let l = 0, f = 0, s = 0, o = 0;
  const { guide: n, matched: m } = e, d = a.getElBoxRect(n.componentView.el), t = a.getElBoxRect(((P = m.componentView) == null ? void 0 : P.el) || m.componentEl), c = d.y, p = d.y + d.height, i = d.x, S = d.x + d.width, E = t.y, b = t.y + t.height, v = t.x, _ = t.x + t.width, x = Math.max(0, c - b), u = Math.max(0, E - p), C = Math.max(0, i - _), M = Math.max(0, v - S), r = x > u, g = C > M, y = n.type;
  return h === "x" && (y === "l" ? (l = i, r ? (f = b, s = x) : (f = p, s = u)) : y === "r" ? (l = S, r ? (f = b, s = x) : (f = p, s = u)) : y === "x" && (l = i - (i - S) / 2, r ? (f = b, s = x) : (f = p, s = u))), h === "y" && (y === "t" ? (f = c, g ? (l = _, o = C) : (l = S, o = M)) : y === "b" ? (f = p, g ? (l = _, o = C) : (l = S, o = M)) : y === "y" && (f = c - (c - p) / 2, g ? (l = _, o = C) : (l = S, o = M))), { axis: h, x: l, y: f, width: o, height: s };
}
function le({
  guideMatched: e,
  component: a,
  canvasView: h
}) {
  const l = e.guide.x === void 0 ? "x" : "y", { guide: f, matched: s } = e, o = f.type, n = s.type, m = h.getElementPos(f.componentView.el).rect, d = h.getElementPos(s.componentView.el).rect;
  if (l === "x") {
    const t = m.height, c = d.top, p = d.top + d.height;
    let i = 0;
    o === "t" ? n === "t" ? i = c - t : n === "b" ? i = p - t : n === "y" && (i = c - t - (c - p) / 2) : o === "b" ? n === "t" ? i = c - t * 2 : n === "b" ? i = p - t * 2 : n === "y" && (i = c - t * 2 - (c - p) / 2) : o === "y" && (n === "t" ? i = c - t * 1.5 : n === "b" ? i = p - t * 1.5 : n === "y" && (i = c - t * 1.5 - (c - p) / 2)), a.addStyle({ top: `${i - 5}px` }, { partial: !0 });
  }
  if (l === "y") {
    const t = m.width, c = d.left, p = d.left + d.width;
    let i = 0;
    o === "l" ? n === "l" ? i = c : n === "r" ? i = p : n === "x" && (i = c - (c - p) / 2) : o === "r" ? n === "l" ? i = c - t : n === "r" ? i = p - t : n === "x" && (i = c - t - (c - p) / 2) : o === "x" && (n === "l" ? i = c - t / 2 : n === "r" && (i = p - t / 2)), a.addStyle({ left: `${i}px` }, { partial: !0 });
  }
}
function H({
  snapping: e,
  editor: a,
  props: h
}) {
  var R, w;
  const { command: l, guidesMatched: f } = h, s = h.component, o = s.getEl(), n = a.Canvas.getCanvasView(), { x: m, y: d } = e ?? { x: 10, y: 10 }, t = l.opts.event, c = t.clientX, p = t.clientY;
  if (!s.__lastSnappedPosition) {
    const A = n.getElBoxRect(o), D = c - A.x, T = p - A.y;
    s.__lastSnappedPosition = { left: A.x, top: A.y }, s.__dragOffset = { x: D, y: T };
  }
  const i = ((R = s.__dragOffset) == null ? void 0 : R.x) || 0, S = ((w = s.__dragOffset) == null ? void 0 : w.y) || 0, E = s.__lastSnappedPosition, b = c - E.left - i, v = p - E.top - S;
  let _ = E.left, x = E.top;
  const u = f == null ? void 0 : f[0], C = (u == null ? void 0 : u.guide.type) === "l", M = (u == null ? void 0 : u.guide.type) === "x", r = (u == null ? void 0 : u.guide.type) === "r", g = (u == null ? void 0 : u.guide.type) === "t", y = (u == null ? void 0 : u.guide.type) === "b", P = (u == null ? void 0 : u.guide.type) === "y";
  if (u) {
    const { x: A, y: D } = B({ guideMatched: u, canvasView: n }), T = o.offsetWidth, G = o.offsetHeight;
    C ? _ = A : r ? _ = A - T : M ? _ = A - T / 2 : g ? x = D : y ? x = D - G : P && (x = D - G / 2), s.__lastSnappedGuideMatched = u;
  } else
    Math.abs(b) >= m && (_ = Math.round((E.left + b) / m) * m, s.__lastSnappedGuideMatched = null), Math.abs(v) >= d && (x = Math.round((E.top + v) / d) * d, s.__lastSnappedGuideMatched = null);
  return s.addStyle({ left: `${_}px`, top: `${x}px` }, { partial: !0 }), s.__lastSnappedPosition = { left: _, top: x }, { x: _, y: x, guideMatched: s.__lastSnappedGuideMatched };
}
function de({
  snapping: e,
  props: a,
  editor: h
}) {
  const { x: l, y: f } = H({ snapping: e, props: a, editor: h }), s = a.component;
  s.addStyle({ left: `${l}px`, top: `${f}px` }), delete s.__lastSnappedPosition, delete s.__lastSnappedGuideMatched;
}
const fe = "core:component-drag", re = "studio:setDragAbsolute", pe = "dmode:start", Y = "dmode:move", K = "dmode:end", $ = "dragAbsolute", ue = "select", he = "hover", me = "spacing", ge = function(e, a = {}) {
  const { Commands: h } = e, l = h.events, f = h.getConfig().defaultOptions ?? {}, s = `${l.runBeforeCommand}tlb-move`;
  f[fe] = {
    run: (r) => ({
      ...r,
      skipGuidesRender: !0
    })
  };
  const { snapping: o, locking: n, globalAbsolute: m = !0 } = a;
  m && e.setDragMode("absolute");
  const d = !!(o != null && o.x || o != null && o.y), t = !!(n != null && n.x || n != null && n.y), { Canvas: c } = e;
  let p = null;
  const i = (r) => {
    const { component: g, guidesMatched: y, command: P } = r, R = g.view, w = e.Canvas.getCanvasView(), A = g.getEl();
    let D = y.map((O) => O.matched.componentEl), T = y.map((O) => B({ guideMatched: O, canvasView: w }));
    if (d) {
      const { guideMatched: O } = H({ snapping: o, props: r, editor: e });
      O ? (D = [O.matched.componentEl], T = [B({ guideMatched: O, canvasView: w })]) : (D = [], T = []);
    }
    if (t)
      if (P.opts.event.shiftKey)
        if (!p)
          p = y[0];
        else {
          const N = p, I = N.guide.x === void 0 ? "x" : "y";
          (I === "x" && (n == null ? void 0 : n.x) || I === "y" && (n == null ? void 0 : n.y)) && (le({ guideMatched: N, component: g, canvasView: w }), D = [N.matched.componentEl], T = [B({ guideMatched: N, canvasView: w })]);
        }
      else
        p = null;
    const G = {
      id: $,
      type: $,
      component: g,
      componentView: R,
      originComponent: A,
      matchedComponents: D,
      originMatchedDistances: T
    };
    c.addSpot(G);
  }, S = ({ enabled: r }) => {
    e.runCommand(re, { enabled: r });
  }, E = ({ type: r }) => {
    c.removeSpots({ type: r });
  }, b = () => {
    E({ type: ue }), E({ type: he }), E({ type: me });
  }, v = (r) => {
    S({ enabled: !0 }), i(r), b();
  }, _ = (r) => {
    i(r), b();
  }, x = (r) => {
    E({ type: $ }), d && de({ snapping: o, props: r, editor: e }), S({ enabled: !1 });
  }, M = [
    [pe, (r) => {
      v(r), e.on(Y, _);
      const g = () => {
        x(r), e.off(Y, _), e.off(K, g);
      };
      e.on(K, g);
    }],
    [s, (r) => {
      if (m) return;
      const g = r.options.target, y = ae(e, g, a);
      y != null && y.result && !y.dmode && (r.options.mode = "absolute");
    }]
  ];
  M.forEach(([r, g]) => e.on(r, g)), se({
    editor: e,
    licenseKey: a.licenseKey,
    plan: ie,
    pluginName: ce,
    cleanup: () => {
      S({ enabled: !1 }), M.forEach(([r, g]) => e.off(r, g));
    }
  });
}, Ee = ne(ge);
export {
  Ee as default
};
