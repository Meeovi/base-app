(function(g,m){typeof exports=="object"&&typeof module<"u"?module.exports=m():typeof define=="function"&&define.amd?define(m):(g=typeof globalThis<"u"?globalThis:g||self,g.StudioSdkPlugins_dataSourceEjs=m())})(this,function(){"use strict";const g="app.grapesjs.com",m="app-stage.grapesjs.com",$=[g,"app2.grapesjs.com",m,"app-stage2.grapesjs.com","localhost","127.0.0.1",".local-credentialless.webcontainer.io",".local.webcontainer.io","-sandpack.codesandbox.io"],I="license:check:start",w="license:check:end",P=()=>typeof window<"u",O=({isDev:o,isStage:t})=>`${o?"":`https://${t?m:g}`}/api`,k=()=>{const o=P()&&window.location.hostname;return!!o&&($.includes(o)||$.some(t=>o.endsWith(t)))};async function L({path:o,baseApiUrl:t,method:e="GET",headers:s={},params:n,body:r}){const a=`${t||O({isDev:!1,isStage:!1})}${o}`,c={method:e,headers:{"Content-Type":"application/json",...s}};r&&(c.body=JSON.stringify(r));const p=n?new URLSearchParams(n).toString():"",l=p?`?${p}`:"",u=await fetch(`${a}${l}`,c);if(!u.ok)throw new Error(`HTTP error! status: ${u.status}`);return u.json()}var y=(o=>(o.free="free",o.startup="startup",o.business="business",o.enterprise="enterprise",o))(y||{});const b={[y.free]:0,[y.startup]:10,[y.business]:20,[y.enterprise]:30};function N(o){const t=o;return t.init=e=>s=>o(s,e),t}const T=o=>N(o);async function C({editor:o,plan:t,pluginName:e,licenseKey:s,cleanup:n}){let r="",i=!1;const a=k(),c=l=>{console.warn("Cleanup plugin:",e,"Reason:",l),n()},p=(l={})=>{var h;const{error:u,sdkLicense:d}=l,f=(h=l.plan)==null?void 0:h.category;if(!(d||l.license)||u)c(u||"Invalid license");else if(f){const E=b[t],x=b[f];E>x&&c({pluginRequiredPlan:t,licensePlan:f})}};o.on(I,l=>{r=l==null?void 0:l.baseApiUrl,i=!0}),o.on(w,l=>{p(l)}),setTimeout(async()=>{if(!i){if(a)return;if(s){const l=await v({licenseKey:s,pluginName:e,baseApiUrl:r});l&&p(l)}else c("The `licenseKey` option not provided")}},2e3)}async function v(o){const{licenseKey:t,pluginName:e,baseApiUrl:s}=o;try{return(await L({baseApiUrl:s,path:`/sdk/${t||"na"}`,method:"POST",params:{d:window.location.hostname,pn:e}})).result||{}}catch(n){return console.error("Error during SDK license check:",n),!1}}const A=o=>{const t=o;return t.logicalOperator==="and"||t.logicalOperator==="or"},M=(o,t)=>(o.config.optsHtml={...o.config.optsHtml,exporter:t},()=>{o.config.optsHtml.exporter=void 0}),B=(o,t)=>{const e=n=>{const{input:r}=n,{contains:i}=t;(!i||r.includes(i))&&(n.input=t.importer.import(r))},s=o.Parser.events.htmlBefore;return o.on(s,e),()=>{o.off(s,e)}};class _{getVariableSyntax({dataResolver:t}){const{defaultValue:e}=t,s=this.getFullPath(t),n=e?` || \`${e}\``:"";return`<%= ${s}${n} %>`}getCollectionStartSyntax({dataResolver:t}){const{collectionId:e,dataSource:s,startIndex:n,endIndex:r}=t,i=(s==null?void 0:s.path)||e||"",a=this._sanitizeVariableName(e);let c="";if(n!==void 0||r!==void 0){const p=n??0,l=r!==void 0?r:"";c=`.slice(${p}${l!==""?`, ${l}`:""})`}return`<% ${i}${c}.forEach(function(currentItem, index, arr) {
const startIndex = parseInt(${n??0}, 10);
const endIndex = startIndex + arr.length;
const ${a}={ currentItem, currentIndex: startIndex + index, remainingItems: endIndex - (startIndex + index)} %>`}_sanitizeVariableName(t){return t.replace(/[^a-zA-Z0-9_$]/g,"_")}getCollectionEndSyntax(){return"<% }) %>"}getConditionalStartSyntax({dataResolver:t}){return`<% if (${this._parseCondition(t.condition)}) { %>`}getConditionElseSyntax(){return"<% } else { %>"}getConditionalEndSyntax(){return"<% } %>"}getFullPath({collectionId:t,path:e,variableType:s}){return(t?[this._sanitizeVariableName(t),s,e].filter(Boolean).join("."):e)||""}_parseCondition(t){if(!t)return"";if(A(t)){const e=t.statements.map(r=>this._parseCondition(r)),s=j[t.logicalOperator];let n=e.length>1?`(${e.join(`)${s}(`)})`:e[0];return t.logicalOperator==="xor"&&(n=`!!(${n})`),n}else{const e=this._parseValue(t.left),s=this._parseValue(t.right);switch(t.operator){case"equals":return`${e} === ${s}`;case">":case"<":case">=":case"<=":case"=":case"!=":return`${e} ${t.operator} ${s}`;case"contains":return`${e}?.includes(${s})`;case"startsWith":return`${e}?.startsWith(${s})`;case"endsWith":return`${e}?.endsWith(${s})`;case"equalsIgnoreCase":return`${e}?.toLowerCase() === ${s}?.toLowerCase()`;case"trimEquals":return`${e}?.trim() === ${s}?.trim()`;case"isTruthy":return`!!${e}`;case"isFalsy":return`!${e}`;case"isDefined":return`${e} !== undefined`;case"isNull":return`${e} === null`;case"isUndefined":return`${e} === undefined`;case"isArray":return`Array.isArray(${e})`;case"isObject":return`typeof ${e} === 'object' && ${e} !== null && !Array.isArray(${e})`;case"isString":return`typeof ${e} === 'string'`;case"isNumber":return`typeof ${e} === 'number' && !isNaN(${e})`;case"isBoolean":return`typeof ${e} === 'boolean'`;default:return`${e} ${t.operator} ${s}`}}}_parseValue(t){return typeof t=="object"?this.getFullPath(t):typeof t=="string"?`'${t.replace(/'/g,"\\'")}'`:String(t)}}const j={and:"&&",or:"||",xor:"^"},W=["===","==","!==","!=","<=",">=","<",">","&&","||"],J={"===":"=","==":"=","!==":"!=","!=":"!=","<=":"<=",">=":">=","<":"<",">":">","&&":"&&","||":"||"};class F{constructor(){this.messages=[],this.collectionStack=[]}import(t){this.messages=[],this.collectionStack=[];try{const e=this.parseEjsTemplate(t);return this.astToGrapesJS(e)}catch(e){return console.error("Error during import:",e),this.addMessage("error",`Error during import: ${e instanceof Error?e.message:String(e)}`),""}}parseEjsTemplate(t){const e=[];let s=0;for(;s<t.length;){const n=t.indexOf("<%",s);if(n===-1){s<t.length&&e.push(this.createAppendLiteral(t.slice(s)));break}n>s&&e.push(this.createAppendLiteral(t.slice(s,n)));const r=t.indexOf("%>",n);if(r===-1)throw new Error("Unclosed EJS tag");const i=t.slice(n+2,r).trim();if(s=r+2,i.startsWith("=")||i.startsWith("-")){const a=i.slice(1).trim();e.push(this.createAppendExpression(a))}else{if(i.startsWith("#"))continue;if(i.startsWith("if")){const a=this.parseIfStatement(i,t,s);e.push(a),s=a.endPos||s}else if(i.startsWith("for")){const a=this.parseForStatement(i,t,s);e.push(a),s=a.endPos||s}else{const a=i.match(/([\w][\w.-]*[\w])\s*\.\s*forEach\s*\(\s*(\w+)\s*=>\s*\{?/);if(a){const c=a[1],p=a[2],l=this.parseForEachStatement(c,p,t,s);e.push(l),s=l.endPos||s}else this.addMessage("info",`Unsupported scriptlet content: ${i}`)}}}return{type:"Program",body:e}}createAppendLiteral(t){return{type:"ExpressionStatement",expression:{type:"CallExpression",callee:{type:"Identifier",name:"__append"},arguments:[{type:"Literal",value:t}]}}}createAppendExpression(t){return{type:"ExpressionStatement",expression:{type:"CallExpression",callee:{type:"Identifier",name:"__append"},arguments:[this.parseJsExpression(t)]}}}parseIfStatement(t,e,s){const n=t.match(/if\s*\((.*)\)\s*\{?/);if(!n)throw new Error("Invalid if statement syntax");const r=this.parseJsExpression(n[1]),{body:i,endPos:a}=this.parseTemplateBlock(e,s);let c=null,p=a;const l=e.indexOf("<%",p);if(l===p){const u=e.indexOf("%>",l);if(u!==-1){const d=e.slice(l+2,u).trim(),f=u+2-l;if(d.startsWith("} else if")){p=l+f;const S=d.substring(d.indexOf("if")).trim(),h=this.parseIfStatement(S,e,p);c={type:"IfStatement",test:h.test,consequent:h.consequent,alternate:h.alternate},p=h.endPos}else if(d.startsWith("} else")){p=l+f;const{body:S,endPos:h}=this.parseTemplateBlock(e,p);c={type:"BlockStatement",body:S},p=h;const E=e.indexOf("<%",p),x=e.indexOf("%>",E);E===p&&e.slice(E+2,x).trim()==="}"&&(p=x+2)}else d==="}"&&(p=l+f)}}return{type:"IfStatement",test:r,consequent:{type:"BlockStatement",body:i},alternate:c,endPos:p}}parseForStatement(t,e,s){const n=t.match(/for\s*\((.*)\)\s*\{?/);if(!n)throw new Error("Invalid for statement syntax");const r=n[1].split("of");if(r.length!==2)throw new Error("Only for...of loops are supported");const i=r[0].trim().replace(/^let\s+|^const\s+|^var\s+/,""),a=r[1].trim(),{body:c,endPos:p}=this.parseTemplateBlock(e,s);return{type:"ForStatement",init:{type:"VariableDeclaration",kind:"let",declarations:[{type:"VariableDeclarator",id:{type:"Identifier",name:i},init:this.parseJsExpression(a)}]},test:null,update:null,body:{type:"BlockStatement",body:c},endPos:(()=>{const l=e.indexOf("<%",p),u=e.indexOf("%>",l);return l===p&&e.slice(l+2,u).trim()==="}"?u+2:p})()}}parseForEachStatement(t,e,s,n){const{body:r,endPos:i}=this.parseTemplateBlock(s,n);return{type:"ForEachStatement",collection:this.parseJsExpression(t),itemIdentifier:{type:"Identifier",name:e},body:{type:"BlockStatement",body:r},endPos:(()=>{const a=s.indexOf("<%",i),c=s.indexOf("%>",a);return a===i&&s.slice(a+2,c).trim()==="}"?c+2:i})()}}parseTemplateBlock(t,e){const s=[];let n=e;for(;n<t.length;){const r=t.indexOf("<%",n);if(r===-1){n<t.length&&s.push(this.createAppendLiteral(t.slice(n))),n=t.length;break}r>n&&s.push(this.createAppendLiteral(t.slice(n,r)));const i=t.indexOf("%>",r);if(i===-1)throw new Error("Unclosed EJS tag within block");const a=t.slice(r+2,i).trim();if(a==="}"||a.startsWith("} else")){n=r;break}if(n=i+2,a.startsWith("=")||a.startsWith("-")){const c=a.slice(1).trim();s.push(this.createAppendExpression(c))}else{if(a.startsWith("#"))continue;if(a.startsWith("if")){const c=this.parseIfStatement(a,t,n);s.push(c),n=c.endPos||n}else if(a.startsWith("for")){const c=this.parseForStatement(a,t,n);s.push(c),n=c.endPos||n}else{const c=a.match(/([\w][\w.-]*[\w])\s*\.\s*forEach\s*\(\s*(\w+)\s*=>\s*\{?/);if(c){const p=c[1],l=c[2],u=this.parseForEachStatement(p,l,t,n);s.push(u),n=u.endPos||n}else this.addMessage("info",`Unsupported scriptlet content within block: ${a}`)}}}return{body:s,endPos:n}}parseJsExpression(t){if(/^(['"]).*\1$/.test(t))return{type:"Literal",value:t.slice(1,-1)};if(/^-?\d+$/.test(t))return{type:"Literal",value:parseInt(t,10)};if(/^-?\d+\.\d+$/.test(t))return{type:"Literal",value:parseFloat(t)};if(t==="true"||t==="false")return{type:"Literal",value:t==="true"};for(const n of W){const r=t.lastIndexOf(n);if(r>0&&t[r-1]!=="!"&&t[r-1]!=="="&&t[r-1]!=="<"&&t[r-1]!==">")return{type:n==="&&"||n==="||"?"LogicalExpression":"BinaryExpression",operator:J[n],left:this.parseJsExpression(t.slice(0,r).trim()),right:this.parseJsExpression(t.slice(r+n.length).trim())}}const e=t.indexOf("."),s=t.indexOf("[");if(e>0&&(s===-1||e<s)||s>0&&(e===-1||s<e)){const n=e>0&&(s===-1||e<s)?e:s;let r,i,a=!1;if(n===e)r=t.slice(0,e),i={type:"Identifier",name:t.slice(e+1)},a=!1;else{r=t.slice(0,s);const c=t.indexOf("]",s);if(c===-1)throw new Error("Unclosed bracket in expression");const p=t.slice(s+1,c);i=/^(['"]).*\1$/.test(p)||/^-?\d+(\.\d+)?$/.test(p)?this.parseJsExpression(p):{type:"Identifier",name:p},a=!0}return{type:"MemberExpression",object:this.parseJsExpression(r),property:i,computed:a}}return{type:"Identifier",name:t}}astToGrapesJS(t){switch(t.type){case"Program":return this.handleProgram(t);case"VariableDeclaration":return this.handleVariableDeclaration(t);case"ExpressionStatement":return this.handleExpressionStatement(t);case"IfStatement":return this.handleIfStatement(t);case"ForStatement":return this.handleForStatement(t);case"ForEachStatement":return this.handleForEachStatement(t);case"BlockStatement":return this.handleBlockStatement(t);case"Literal":return this.handleLiteral(t);case"Identifier":return this.handleIdentifier(t);case"MemberExpression":return this.handleMemberExpression(t);case"BinaryExpression":return this.handleBinaryExpression(t);case"LogicalExpression":return this.handleLogicalExpression(t);case"CallExpression":return this.handleCallExpression(t);default:return this.addMessage("warning",`Unsupported node type: ${t.type}`),""}}handleProgram(t){let e="";for(const s of t.body)e+=this.astToGrapesJS(s);return e}handleVariableDeclaration(t){return""}handleExpressionStatement(t){return t.expression.type==="CallExpression"&&t.expression.callee.type==="Identifier"&&t.expression.callee.name==="__append"&&t.expression.arguments.length>0?this.astToGrapesJS(t.expression.arguments[0]):""}handleIfStatement(t){const e=this.getConditionExpression(t.test),s=this.astToGrapesJS(t.consequent);let n="";return t.alternate&&(n=this.astToGrapesJS(t.alternate)),`
      <data-condition data-gjs-data-resolver='${JSON.stringify({condition:e})}'>
        <data-condition-true-content>${s}</data-condition-true-content>
        <data-condition-false-content>${n}</data-condition-false-content>
      </data-condition>
    `}handleForStatement(t){var a;if(((a=t.init)==null?void 0:a.type)!=="VariableDeclaration"||t.init.declarations.length===0)return this.addMessage("warning","Unsupported for loop init format"),"";const e=t.init.declarations[0];if(e.id.type!=="Identifier")return this.addMessage("warning","Unsupported for loop variable declaration id"),"";let s="";if(e.init)s=this.getExpressionString(e.init);else return this.addMessage("warning","For loop collection is undefined"),"";const n=e.id.name,r=n;this.collectionStack.push(n);const i=this.astToGrapesJS(t.body);return this.collectionStack.pop(),`
      <data-collection data-gjs-data-resolver='${JSON.stringify({dataSource:{type:"data-variable",path:s},collectionId:r})}'>
        <data-collection-item>
          ${i}
        </data-collection-item>
      </data-collection>
    `}handleForEachStatement(t){const e=this.getExpressionString(t.collection),s=t.itemIdentifier.name,n=s;this.collectionStack.push(s);const r=this.astToGrapesJS(t.body);return this.collectionStack.pop(),`
      <data-collection data-gjs-data-resolver='${JSON.stringify({dataSource:{type:"data-variable",path:e},collectionId:n})}'>
        <data-collection-item>
          ${r}
        </data-collection-item>
      </data-collection>
    `}handleBlockStatement(t){let e="";for(const s of t.body)e+=this.astToGrapesJS(s);return e}handleLiteral(t){return String(t.value??"")}handleIdentifier(t){let e={path:t.name};if(this.collectionStack.length>0){const s=this.collectionStack[this.collectionStack.length-1];t.name===s&&(e={collectionId:s,variableType:"currentItem"})}return`<data-variable data-gjs-data-resolver='${JSON.stringify(e)}'></data-variable>`}handleMemberExpression(t,e={}){let n={path:this.getExpressionString(t),...e};if(this.collectionStack.length>0){const r=this.collectionStack[this.collectionStack.length-1];let i=t;const a=[];for(;i.type==="MemberExpression";)i.property.type==="Identifier"&&!i.computed?a.unshift(i.property.name):i.property.type==="Literal"&&i.computed?a.unshift(String(i.property.value)):a.unshift(this.getExpressionString(i.property)),i=i.object;if(i.type==="Identifier"&&i.name===r){const c=a.join(".");n={...e,collectionId:r,variableType:"currentItem",path:c}}}return`<data-variable data-gjs-data-resolver='${JSON.stringify(n)}'></data-variable>`}handleBinaryExpression(t){return`${this.getExpressionString(t.left)} ${t.operator} ${this.getExpressionString(t.right)}`}handleLogicalExpression(t){return t.operator==="||"&&t.right.type==="Literal"?this.handleMemberExpression(t.left,{defaultValue:t.right.value}):`${this.getExpressionString(t.left)} ${t.operator} ${this.getExpressionString(t.right)}`}handleCallExpression(t){var e;if(t.callee.type==="Identifier"&&t.callee.name==="include"){const s=((e=t.arguments[0])==null?void 0:e.type)==="Literal"?String(t.arguments[0].value):"";return this.addMessage("info",`Partial includes are not fully supported: ${s}`),""}return""}getConditionExpression(t){if(t.type==="Identifier")return{logicalOperator:"and",statements:[{left:{type:"data-variable",path:t.name},operator:"isTruthy"}]};if(t.type==="MemberExpression"){let e=this.getExpressionString(t),s="isTruthy";return e.startsWith("!!")?(s="isTruthy",e=e.slice(2)):e.startsWith("!")&&(s="isFalsy",e=e.slice(1)),{logicalOperator:"and",statements:[{left:{type:"data-variable",path:e},operator:s}]}}if(t.type==="BinaryExpression"||t.type==="LogicalExpression"){const e=this.getConditionExpression(t.left),s=this.getConditionExpression(t.right);return`${e} ${t.operator} ${s}`}return t.type==="Literal"?typeof t.value=="string"?`'${t.value}'`:String(t.value??""):this.getExpressionString(t)}getExpressionString(t){switch(t.type){case"Identifier":return t.name;case"Literal":return String(t.value??"");case"MemberExpression":{const e=this.getExpressionString(t.object),s=this.getExpressionString(t.property);return t.computed?`${e}[${s}]`:`${e}.${s}`}case"BinaryExpression":{const e=this.getExpressionString(t.left),s=this.getExpressionString(t.right);return`${e} ${t.operator} ${s}`}case"LogicalExpression":{const e=this.getExpressionString(t.left),s=this.getExpressionString(t.right);return`${e} ${t.operator} ${s}`}default:return this.addMessage("warning",`Unsupported expression type for getExpressionString: ${t.type}`),""}}addMessage(t,e){this.messages.push({type:t,message:e})}}const D="dataSourceEjs",U=y.startup;return T(function(o,t={}){const e=M(o,new _),s=B(o,{contains:"<%",importer:new F});C({editor:o,licenseKey:t.licenseKey,plan:U,pluginName:D,cleanup:()=>{e(),s()}})})});
