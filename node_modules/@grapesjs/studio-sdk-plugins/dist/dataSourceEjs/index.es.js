const $ = "app.grapesjs.com", b = "app-stage.grapesjs.com", I = "app2.grapesjs.com", w = "app-stage2.grapesjs.com", S = [
  $,
  I,
  b,
  w,
  "localhost",
  "127.0.0.1",
  ".local-credentialless.webcontainer.io",
  // For stackblitz.com demos
  ".local.webcontainer.io",
  // For stackblitz.com demos
  "-sandpack.codesandbox.io"
  // For Sandpack demos
], P = "license:check:start", O = "license:check:end", k = () => typeof window < "u", L = ({ isDev: o, isStage: t }) => `${o ? "" : `https://${t ? b : $}`}/api`, C = () => {
  const o = k() && window.location.hostname;
  return !!o && (S.includes(o) || S.some((t) => o.endsWith(t)));
};
async function N({
  path: o,
  baseApiUrl: t,
  method: e = "GET",
  headers: s = {},
  params: n,
  body: r
}) {
  const a = `${t || L({ isDev: !1, isStage: !1 })}${o}`, c = {
    method: e,
    headers: {
      "Content-Type": "application/json",
      ...s
    }
  };
  r && (c.body = JSON.stringify(r));
  const p = n ? new URLSearchParams(n).toString() : "", l = p ? `?${p}` : "", h = await fetch(`${a}${l}`, c);
  if (!h.ok)
    throw new Error(`HTTP error! status: ${h.status}`);
  return h.json();
}
var g = /* @__PURE__ */ ((o) => (o.free = "free", o.startup = "startup", o.business = "business", o.enterprise = "enterprise", o))(g || {});
const x = {
  [g.free]: 0,
  [g.startup]: 10,
  [g.business]: 20,
  [g.enterprise]: 30
};
function v(o) {
  const t = o;
  return t.init = (e) => (s) => o(s, e), t;
}
const T = (o) => /* @__PURE__ */ v(o);
async function B({
  editor: o,
  plan: t,
  pluginName: e,
  licenseKey: s,
  cleanup: n
}) {
  let r = "", i = !1;
  const a = C(), c = (l) => {
    console.warn("Cleanup plugin:", e, "Reason:", l), n();
  }, p = (l = {}) => {
    var u;
    const { error: h, sdkLicense: d } = l, f = (u = l.plan) == null ? void 0 : u.category;
    if (!(d || l.license) || h)
      c(h || "Invalid license");
    else if (f) {
      const m = x[t], E = x[f];
      m > E && c({ pluginRequiredPlan: t, licensePlan: f });
    }
  };
  o.on(P, (l) => {
    r = l == null ? void 0 : l.baseApiUrl, i = !0;
  }), o.on(O, (l) => {
    p(l);
  }), setTimeout(async () => {
    if (!i) {
      if (a) return;
      if (s) {
        const l = await A({ licenseKey: s, pluginName: e, baseApiUrl: r });
        l && p(l);
      } else
        c("The `licenseKey` option not provided");
    }
  }, 2e3);
}
async function A(o) {
  const { licenseKey: t, pluginName: e, baseApiUrl: s } = o;
  try {
    return (await N({
      baseApiUrl: s,
      path: `/sdk/${t || "na"}`,
      method: "POST",
      params: {
        d: window.location.hostname,
        pn: e
      }
    })).result || {};
  } catch (n) {
    return console.error("Error during SDK license check:", n), !1;
  }
}
const M = (o) => {
  const t = o;
  return t.logicalOperator === "and" || t.logicalOperator === "or";
}, j = (o, t) => (o.config.optsHtml = {
  ...o.config.optsHtml,
  exporter: t
}, () => {
  o.config.optsHtml.exporter = void 0;
}), W = (o, t) => {
  const e = (n) => {
    const { input: r } = n, { contains: i } = t;
    (!i || r.includes(i)) && (n.input = t.importer.import(r));
  }, s = o.Parser.events.htmlBefore;
  return o.on(s, e), () => {
    o.off(s, e);
  };
};
class _ {
  getVariableSyntax({ dataResolver: t }) {
    const { defaultValue: e } = t, s = this.getFullPath(t), n = e ? ` || \`${e}\`` : "";
    return `<%= ${s}${n} %>`;
  }
  getCollectionStartSyntax({ dataResolver: t }) {
    const { collectionId: e, dataSource: s, startIndex: n, endIndex: r } = t, i = (s == null ? void 0 : s.path) || e || "", a = this._sanitizeVariableName(e);
    let c = "";
    if (n !== void 0 || r !== void 0) {
      const p = n ?? 0, l = r !== void 0 ? r : "";
      c = `.slice(${p}${l !== "" ? `, ${l}` : ""})`;
    }
    return `<% ${i}${c}.forEach(function(currentItem, index, arr) {
const startIndex = parseInt(${n ?? 0}, 10);
const endIndex = startIndex + arr.length;
const ${a}={ currentItem, currentIndex: startIndex + index, remainingItems: endIndex - (startIndex + index)} %>`;
  }
  _sanitizeVariableName(t) {
    return t.replace(/[^a-zA-Z0-9_$]/g, "_");
  }
  getCollectionEndSyntax() {
    return "<% }) %>";
  }
  getConditionalStartSyntax({ dataResolver: t }) {
    return `<% if (${this._parseCondition(t.condition)}) { %>`;
  }
  getConditionElseSyntax() {
    return "<% } else { %>";
  }
  getConditionalEndSyntax() {
    return "<% } %>";
  }
  getFullPath({ collectionId: t, path: e, variableType: s }) {
    return (t ? [this._sanitizeVariableName(t), s, e].filter(Boolean).join(".") : e) || "";
  }
  _parseCondition(t) {
    if (!t) return "";
    if (M(t)) {
      const e = t.statements.map((r) => this._parseCondition(r)), s = J[t.logicalOperator];
      let n = e.length > 1 ? `(${e.join(`)${s}(`)})` : e[0];
      return t.logicalOperator === "xor" && (n = `!!(${n})`), n;
    } else {
      const e = this._parseValue(t.left), s = this._parseValue(t.right);
      switch (t.operator) {
        case "equals":
          return `${e} === ${s}`;
        case ">":
        case "<":
        case ">=":
        case "<=":
        case "=":
        case "!=":
          return `${e} ${t.operator} ${s}`;
        case "contains":
          return `${e}?.includes(${s})`;
        case "startsWith":
          return `${e}?.startsWith(${s})`;
        case "endsWith":
          return `${e}?.endsWith(${s})`;
        case "equalsIgnoreCase":
          return `${e}?.toLowerCase() === ${s}?.toLowerCase()`;
        case "trimEquals":
          return `${e}?.trim() === ${s}?.trim()`;
        case "isTruthy":
          return `!!${e}`;
        case "isFalsy":
          return `!${e}`;
        case "isDefined":
          return `${e} !== undefined`;
        case "isNull":
          return `${e} === null`;
        case "isUndefined":
          return `${e} === undefined`;
        case "isArray":
          return `Array.isArray(${e})`;
        case "isObject":
          return `typeof ${e} === 'object' && ${e} !== null && !Array.isArray(${e})`;
        case "isString":
          return `typeof ${e} === 'string'`;
        case "isNumber":
          return `typeof ${e} === 'number' && !isNaN(${e})`;
        case "isBoolean":
          return `typeof ${e} === 'boolean'`;
        default:
          return `${e} ${t.operator} ${s}`;
      }
    }
  }
  _parseValue(t) {
    return typeof t == "object" ? this.getFullPath(t) : typeof t == "string" ? `'${t.replace(/'/g, "\\'")}'` : String(t);
  }
}
const J = {
  and: "&&",
  or: "||",
  xor: "^"
}, F = ["===", "==", "!==", "!=", "<=", ">=", "<", ">", "&&", "||"], U = {
  "===": "=",
  "==": "=",
  "!==": "!=",
  "!=": "!=",
  "<=": "<=",
  ">=": ">=",
  "<": "<",
  ">": ">",
  "&&": "&&",
  "||": "||"
};
class D {
  constructor() {
    this.messages = [], this.collectionStack = [];
  }
  import(t) {
    this.messages = [], this.collectionStack = [];
    try {
      const e = this.parseEjsTemplate(t);
      return this.astToGrapesJS(e);
    } catch (e) {
      return console.error("Error during import:", e), this.addMessage("error", `Error during import: ${e instanceof Error ? e.message : String(e)}`), "";
    }
  }
  parseEjsTemplate(t) {
    const e = [];
    let s = 0;
    for (; s < t.length; ) {
      const n = t.indexOf("<%", s);
      if (n === -1) {
        s < t.length && e.push(this.createAppendLiteral(t.slice(s)));
        break;
      }
      n > s && e.push(this.createAppendLiteral(t.slice(s, n)));
      const r = t.indexOf("%>", n);
      if (r === -1)
        throw new Error("Unclosed EJS tag");
      const i = t.slice(n + 2, r).trim();
      if (s = r + 2, i.startsWith("=") || i.startsWith("-")) {
        const a = i.slice(1).trim();
        e.push(this.createAppendExpression(a));
      } else {
        if (i.startsWith("#"))
          continue;
        if (i.startsWith("if")) {
          const a = this.parseIfStatement(i, t, s);
          e.push(a), s = a.endPos || s;
        } else if (i.startsWith("for")) {
          const a = this.parseForStatement(i, t, s);
          e.push(a), s = a.endPos || s;
        } else {
          const a = i.match(/([\w][\w.-]*[\w])\s*\.\s*forEach\s*\(\s*(\w+)\s*=>\s*\{?/);
          if (a) {
            const c = a[1], p = a[2], l = this.parseForEachStatement(c, p, t, s);
            e.push(l), s = l.endPos || s;
          } else
            this.addMessage("info", `Unsupported scriptlet content: ${i}`);
        }
      }
    }
    return {
      type: "Program",
      body: e
    };
  }
  createAppendLiteral(t) {
    return {
      type: "ExpressionStatement",
      expression: {
        type: "CallExpression",
        callee: { type: "Identifier", name: "__append" },
        arguments: [{ type: "Literal", value: t }]
      }
    };
  }
  createAppendExpression(t) {
    return {
      type: "ExpressionStatement",
      expression: {
        type: "CallExpression",
        callee: { type: "Identifier", name: "__append" },
        arguments: [this.parseJsExpression(t)]
      }
    };
  }
  parseIfStatement(t, e, s) {
    const n = t.match(/if\s*\((.*)\)\s*\{?/);
    if (!n)
      throw new Error("Invalid if statement syntax");
    const r = this.parseJsExpression(n[1]), { body: i, endPos: a } = this.parseTemplateBlock(e, s);
    let c = null, p = a;
    const l = e.indexOf("<%", p);
    if (l === p) {
      const h = e.indexOf("%>", l);
      if (h !== -1) {
        const d = e.slice(l + 2, h).trim(), f = h + 2 - l;
        if (d.startsWith("} else if")) {
          p = l + f;
          const y = d.substring(d.indexOf("if")).trim(), u = this.parseIfStatement(y, e, p);
          c = {
            type: "IfStatement",
            test: u.test,
            consequent: u.consequent,
            alternate: u.alternate
          }, p = u.endPos;
        } else if (d.startsWith("} else")) {
          p = l + f;
          const { body: y, endPos: u } = this.parseTemplateBlock(e, p);
          c = {
            type: "BlockStatement",
            body: y
          }, p = u;
          const m = e.indexOf("<%", p), E = e.indexOf("%>", m);
          m === p && e.slice(m + 2, E).trim() === "}" && (p = E + 2);
        } else d === "}" && (p = l + f);
      }
    }
    return {
      type: "IfStatement",
      test: r,
      consequent: {
        type: "BlockStatement",
        body: i
      },
      alternate: c,
      endPos: p
    };
  }
  parseForStatement(t, e, s) {
    const n = t.match(/for\s*\((.*)\)\s*\{?/);
    if (!n)
      throw new Error("Invalid for statement syntax");
    const r = n[1].split("of");
    if (r.length !== 2)
      throw new Error("Only for...of loops are supported");
    const i = r[0].trim().replace(/^let\s+|^const\s+|^var\s+/, ""), a = r[1].trim(), { body: c, endPos: p } = this.parseTemplateBlock(e, s);
    return {
      type: "ForStatement",
      init: {
        type: "VariableDeclaration",
        kind: "let",
        declarations: [
          {
            type: "VariableDeclarator",
            id: { type: "Identifier", name: i },
            init: this.parseJsExpression(a)
          }
        ]
      },
      test: null,
      update: null,
      body: {
        type: "BlockStatement",
        body: c
      },
      // Consume the closing '}' tag for the for loop
      endPos: (() => {
        const l = e.indexOf("<%", p), h = e.indexOf("%>", l);
        return l === p && e.slice(l + 2, h).trim() === "}" ? h + 2 : p;
      })()
    };
  }
  parseForEachStatement(t, e, s, n) {
    const { body: r, endPos: i } = this.parseTemplateBlock(s, n);
    return {
      type: "ForEachStatement",
      collection: this.parseJsExpression(t),
      itemIdentifier: { type: "Identifier", name: e },
      body: {
        type: "BlockStatement",
        body: r
      },
      endPos: (() => {
        const a = s.indexOf("<%", i), c = s.indexOf("%>", a);
        return a === i && s.slice(a + 2, c).trim() === "}" ? c + 2 : i;
      })()
    };
  }
  parseTemplateBlock(t, e) {
    const s = [];
    let n = e;
    for (; n < t.length; ) {
      const r = t.indexOf("<%", n);
      if (r === -1) {
        n < t.length && s.push(this.createAppendLiteral(t.slice(n))), n = t.length;
        break;
      }
      r > n && s.push(this.createAppendLiteral(t.slice(n, r)));
      const i = t.indexOf("%>", r);
      if (i === -1)
        throw new Error("Unclosed EJS tag within block");
      const a = t.slice(r + 2, i).trim();
      if (a === "}" || a.startsWith("} else")) {
        n = r;
        break;
      }
      if (n = i + 2, a.startsWith("=") || a.startsWith("-")) {
        const c = a.slice(1).trim();
        s.push(this.createAppendExpression(c));
      } else {
        if (a.startsWith("#"))
          continue;
        if (a.startsWith("if")) {
          const c = this.parseIfStatement(a, t, n);
          s.push(c), n = c.endPos || n;
        } else if (a.startsWith("for")) {
          const c = this.parseForStatement(a, t, n);
          s.push(c), n = c.endPos || n;
        } else {
          const c = a.match(/([\w][\w.-]*[\w])\s*\.\s*forEach\s*\(\s*(\w+)\s*=>\s*\{?/);
          if (c) {
            const p = c[1], l = c[2], h = this.parseForEachStatement(p, l, t, n);
            s.push(h), n = h.endPos || n;
          } else
            this.addMessage("info", `Unsupported scriptlet content within block: ${a}`);
        }
      }
    }
    return { body: s, endPos: n };
  }
  parseJsExpression(t) {
    if (/^(['"]).*\1$/.test(t))
      return {
        type: "Literal",
        value: t.slice(1, -1)
      };
    if (/^-?\d+$/.test(t))
      return {
        type: "Literal",
        value: parseInt(t, 10)
      };
    if (/^-?\d+\.\d+$/.test(t))
      return {
        type: "Literal",
        value: parseFloat(t)
      };
    if (t === "true" || t === "false")
      return {
        type: "Literal",
        value: t === "true"
      };
    for (const n of F) {
      const r = t.lastIndexOf(n);
      if (r > 0 && t[r - 1] !== "!" && t[r - 1] !== "=" && t[r - 1] !== "<" && t[r - 1] !== ">")
        return {
          type: n === "&&" || n === "||" ? "LogicalExpression" : "BinaryExpression",
          operator: U[n],
          left: this.parseJsExpression(t.slice(0, r).trim()),
          right: this.parseJsExpression(t.slice(r + n.length).trim())
        };
    }
    const e = t.indexOf("."), s = t.indexOf("[");
    if (e > 0 && (s === -1 || e < s) || s > 0 && (e === -1 || s < e)) {
      const n = e > 0 && (s === -1 || e < s) ? e : s;
      let r, i, a = !1;
      if (n === e)
        r = t.slice(0, e), i = { type: "Identifier", name: t.slice(e + 1) }, a = !1;
      else {
        r = t.slice(0, s);
        const c = t.indexOf("]", s);
        if (c === -1)
          throw new Error("Unclosed bracket in expression");
        const p = t.slice(s + 1, c);
        i = /^(['"]).*\1$/.test(p) || /^-?\d+(\.\d+)?$/.test(p) ? this.parseJsExpression(p) : { type: "Identifier", name: p }, a = !0;
      }
      return {
        type: "MemberExpression",
        object: this.parseJsExpression(r),
        property: i,
        computed: a
      };
    }
    return {
      type: "Identifier",
      name: t
    };
  }
  astToGrapesJS(t) {
    switch (t.type) {
      case "Program":
        return this.handleProgram(t);
      case "VariableDeclaration":
        return this.handleVariableDeclaration(t);
      case "ExpressionStatement":
        return this.handleExpressionStatement(t);
      case "IfStatement":
        return this.handleIfStatement(t);
      case "ForStatement":
        return this.handleForStatement(t);
      case "ForEachStatement":
        return this.handleForEachStatement(t);
      case "BlockStatement":
        return this.handleBlockStatement(t);
      case "Literal":
        return this.handleLiteral(t);
      case "Identifier":
        return this.handleIdentifier(t);
      case "MemberExpression":
        return this.handleMemberExpression(t);
      case "BinaryExpression":
        return this.handleBinaryExpression(t);
      case "LogicalExpression":
        return this.handleLogicalExpression(t);
      case "CallExpression":
        return this.handleCallExpression(t);
      default:
        return this.addMessage("warning", `Unsupported node type: ${t.type}`), "";
    }
  }
  handleProgram(t) {
    let e = "";
    for (const s of t.body)
      e += this.astToGrapesJS(s);
    return e;
  }
  handleVariableDeclaration(t) {
    return "";
  }
  handleExpressionStatement(t) {
    return t.expression.type === "CallExpression" && t.expression.callee.type === "Identifier" && t.expression.callee.name === "__append" && t.expression.arguments.length > 0 ? this.astToGrapesJS(t.expression.arguments[0]) : "";
  }
  handleIfStatement(t) {
    const e = this.getConditionExpression(t.test), s = this.astToGrapesJS(t.consequent);
    let n = "";
    return t.alternate && (n = this.astToGrapesJS(t.alternate)), `
      <data-condition data-gjs-data-resolver='${JSON.stringify({ condition: e })}'>
        <data-condition-true-content>${s}</data-condition-true-content>
        <data-condition-false-content>${n}</data-condition-false-content>
      </data-condition>
    `;
  }
  handleForStatement(t) {
    var a;
    if (((a = t.init) == null ? void 0 : a.type) !== "VariableDeclaration" || t.init.declarations.length === 0)
      return this.addMessage("warning", "Unsupported for loop init format"), "";
    const e = t.init.declarations[0];
    if (e.id.type !== "Identifier")
      return this.addMessage("warning", "Unsupported for loop variable declaration id"), "";
    let s = "";
    if (e.init)
      s = this.getExpressionString(e.init);
    else
      return this.addMessage("warning", "For loop collection is undefined"), "";
    const n = e.id.name, r = n;
    this.collectionStack.push(n);
    const i = this.astToGrapesJS(t.body);
    return this.collectionStack.pop(), `
      <data-collection data-gjs-data-resolver='${JSON.stringify({
      dataSource: { type: "data-variable", path: s },
      collectionId: r
    })}'>
        <data-collection-item>
          ${i}
        </data-collection-item>
      </data-collection>
    `;
  }
  handleForEachStatement(t) {
    const e = this.getExpressionString(t.collection), s = t.itemIdentifier.name, n = s;
    this.collectionStack.push(s);
    const r = this.astToGrapesJS(t.body);
    return this.collectionStack.pop(), `
      <data-collection data-gjs-data-resolver='${JSON.stringify({
      dataSource: { type: "data-variable", path: e },
      collectionId: n
    })}'>
        <data-collection-item>
          ${r}
        </data-collection-item>
      </data-collection>
    `;
  }
  handleBlockStatement(t) {
    let e = "";
    for (const s of t.body)
      e += this.astToGrapesJS(s);
    return e;
  }
  handleLiteral(t) {
    return String(t.value ?? "");
  }
  handleIdentifier(t) {
    let e = { path: t.name };
    if (this.collectionStack.length > 0) {
      const s = this.collectionStack[this.collectionStack.length - 1];
      t.name === s && (e = {
        collectionId: s,
        variableType: "currentItem"
      });
    }
    return `<data-variable data-gjs-data-resolver='${JSON.stringify(e)}'></data-variable>`;
  }
  handleMemberExpression(t, e = {}) {
    let n = { path: this.getExpressionString(t), ...e };
    if (this.collectionStack.length > 0) {
      const r = this.collectionStack[this.collectionStack.length - 1];
      let i = t;
      const a = [];
      for (; i.type === "MemberExpression"; )
        i.property.type === "Identifier" && !i.computed ? a.unshift(i.property.name) : i.property.type === "Literal" && i.computed ? a.unshift(String(i.property.value)) : a.unshift(this.getExpressionString(i.property)), i = i.object;
      if (i.type === "Identifier" && i.name === r) {
        const c = a.join(".");
        n = {
          ...e,
          collectionId: r,
          variableType: "currentItem",
          path: c
        };
      }
    }
    return `<data-variable data-gjs-data-resolver='${JSON.stringify(n)}'></data-variable>`;
  }
  handleBinaryExpression(t) {
    return `${this.getExpressionString(t.left)} ${t.operator} ${this.getExpressionString(t.right)}`;
  }
  handleLogicalExpression(t) {
    return t.operator === "||" && t.right.type === "Literal" ? this.handleMemberExpression(t.left, {
      defaultValue: t.right.value
    }) : `${this.getExpressionString(t.left)} ${t.operator} ${this.getExpressionString(t.right)}`;
  }
  handleCallExpression(t) {
    var e;
    if (t.callee.type === "Identifier" && t.callee.name === "include") {
      const s = ((e = t.arguments[0]) == null ? void 0 : e.type) === "Literal" ? String(t.arguments[0].value) : "";
      return this.addMessage("info", `Partial includes are not fully supported: ${s}`), "";
    }
    return "";
  }
  getConditionExpression(t) {
    if (t.type === "Identifier")
      return {
        logicalOperator: "and",
        statements: [
          {
            left: { type: "data-variable", path: t.name },
            operator: "isTruthy"
          }
        ]
      };
    if (t.type === "MemberExpression") {
      let e = this.getExpressionString(t), s = "isTruthy";
      return e.startsWith("!!") ? (s = "isTruthy", e = e.slice(2)) : e.startsWith("!") && (s = "isFalsy", e = e.slice(1)), {
        logicalOperator: "and",
        statements: [
          {
            left: { type: "data-variable", path: e },
            operator: s
          }
        ]
      };
    }
    if (t.type === "BinaryExpression" || t.type === "LogicalExpression") {
      const e = this.getConditionExpression(t.left), s = this.getConditionExpression(t.right);
      return `${e} ${t.operator} ${s}`;
    }
    return t.type === "Literal" ? typeof t.value == "string" ? `'${t.value}'` : String(t.value ?? "") : this.getExpressionString(t);
  }
  getExpressionString(t) {
    switch (t.type) {
      case "Identifier":
        return t.name;
      case "Literal":
        return String(t.value ?? "");
      case "MemberExpression": {
        const e = this.getExpressionString(t.object), s = this.getExpressionString(t.property);
        return t.computed ? `${e}[${s}]` : `${e}.${s}`;
      }
      case "BinaryExpression": {
        const e = this.getExpressionString(t.left), s = this.getExpressionString(t.right);
        return `${e} ${t.operator} ${s}`;
      }
      case "LogicalExpression": {
        const e = this.getExpressionString(t.left), s = this.getExpressionString(t.right);
        return `${e} ${t.operator} ${s}`;
      }
      default:
        return this.addMessage("warning", `Unsupported expression type for getExpressionString: ${t.type}`), "";
    }
  }
  addMessage(t, e) {
    this.messages.push({
      type: t,
      message: e
    });
  }
}
const V = "dataSourceEjs", G = g.startup, q = function(o, t = {}) {
  const e = j(o, new _()), s = W(o, {
    contains: "<%",
    importer: new D()
  });
  B({
    editor: o,
    licenseKey: t.licenseKey,
    plan: G,
    pluginName: V,
    cleanup: () => {
      e(), s();
    }
  });
}, H = T(q);
export {
  H as default
};
