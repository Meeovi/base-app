const pe = "app.grapesjs.com", de = "app-stage.grapesjs.com", Se = "app2.grapesjs.com", ye = "app-stage2.grapesjs.com", se = [
  pe,
  Se,
  de,
  ye,
  "localhost",
  "127.0.0.1",
  ".local-credentialless.webcontainer.io",
  // For stackblitz.com demos
  ".local.webcontainer.io",
  // For stackblitz.com demos
  "-sandpack.codesandbox.io"
  // For Sandpack demos
], be = "license:check:start", Ce = "license:check:end", Pe = () => typeof window < "u", ze = ({ isDev: n, isStage: e }) => `${n ? "" : `https://${e ? de : pe}`}/api`, xe = () => {
  const n = Pe() && window.location.hostname;
  return !!n && (se.includes(n) || se.some((e) => n.endsWith(e)));
};
function we(n) {
  return typeof n == "function";
}
async function Ie({
  path: n,
  baseApiUrl: e,
  method: t = "GET",
  headers: s = {},
  params: i,
  body: a
}) {
  const l = `${e || ze({ isDev: !1, isStage: !1 })}${n}`, c = {
    method: t,
    headers: {
      "Content-Type": "application/json",
      ...s
    }
  };
  a && (c.body = JSON.stringify(a));
  const g = i ? new URLSearchParams(i).toString() : "", p = g ? `?${g}` : "", u = await fetch(`${l}${p}`, c);
  if (!u.ok)
    throw new Error(`HTTP error! status: ${u.status}`);
  return u.json();
}
var $ = /* @__PURE__ */ ((n) => (n.free = "free", n.startup = "startup", n.business = "business", n.enterprise = "enterprise", n))($ || {}), ue = /* @__PURE__ */ ((n) => (n.web = "web", n.email = "email", n.document = "document", n.react = "react", n))(ue || {});
const ie = {
  [$.free]: 0,
  [$.startup]: 10,
  [$.business]: 20,
  [$.enterprise]: 30
};
function ve(n) {
  const e = n;
  return e.init = (t) => (s) => n(s, t), e;
}
const Re = (n) => /* @__PURE__ */ ve(n);
async function Ge({
  editor: n,
  plan: e,
  pluginName: t,
  licenseKey: s,
  cleanup: i
}) {
  let a = "", o = !1;
  const l = xe(), c = (p) => {
    console.warn("Cleanup plugin:", t, "Reason:", p), i();
  }, g = (p = {}) => {
    var y;
    const { error: u, sdkLicense: f } = p, I = (y = p.plan) == null ? void 0 : y.category;
    if (!(f || p.license) || u)
      c(u || "Invalid license");
    else if (I) {
      const v = ie[e], R = ie[I];
      v > R && c({ pluginRequiredPlan: e, licensePlan: I });
    }
  };
  n.on(be, (p) => {
    a = p == null ? void 0 : p.baseApiUrl, o = !0;
  }), n.on(Ce, (p) => {
    g(p);
  }), setTimeout(async () => {
    if (!o) {
      if (l) return;
      if (s) {
        const p = await Ee({ licenseKey: s, pluginName: t, baseApiUrl: a });
        p && g(p);
      } else
        c("The `licenseKey` option not provided");
    }
  }, 2e3);
}
async function Ee(n) {
  const { licenseKey: e, pluginName: t, baseApiUrl: s } = n;
  try {
    return (await Ie({
      baseApiUrl: s,
      path: `/sdk/${e || "na"}`,
      method: "POST",
      params: {
        d: window.location.hostname,
        pn: t
      }
    })).result || {};
  } catch (i) {
    return console.error("Error during SDK license check:", i), !1;
  }
}
const he = (n) => (e) => {
  var t;
  return ((t = e.getAttribute) == null ? void 0 : t.call(e, te)) === n;
}, Te = (...n) => (e) => n.some((t) => e.is(t)), Le = (...n) => (e, t) => n.some((s) => t.is(s)), ge = "gjs-plg-", te = "data-type-role", N = class N {
  constructor(e) {
    this.config = e;
  }
  getSize(e) {
    var t;
    return (t = this.config) != null && t.getSize ? this.config.getSize(e) : ne(e.componentColumn, N.CSS_FLEX_BASIS);
  }
  setSize(e) {
    var t;
    if ((t = this.config) != null && t.setSize)
      this.config.setSize(e);
    else {
      const { componentColumn: s, sizeValue: i, partial: a } = e;
      s.addStyle({ [N.CSS_FLEX_BASIS]: i }, { partial: a });
    }
  }
};
N.CSS_FLEX_BASIS = "flex-basis";
let W = N;
const j = class j {
  constructor(e) {
    this.config = e;
  }
  isGapSupported() {
    return !0;
  }
  getGap(e) {
    var t;
    return (t = this.config) != null && t.getGap ? this.config.getGap(e) : ne(e.componentRow, j.CSS_GAP);
  }
  setGap(e) {
    var t;
    if ((t = this.config) != null && t.setGap)
      this.config.setGap(e);
    else {
      const { componentRow: s, gapValue: i, partial: a } = e;
      s.addStyle({ [j.CSS_GAP]: i }, { partial: a });
    }
  }
};
j.CSS_GAP = "gap";
let K = j;
const X = class X {
  constructor(e) {
    this.config = e;
  }
  getParentSize(e) {
    var a;
    if ((a = this.config) != null && a.getParentSize) return this.config.getParentSize(e);
    const { componentRow: t, isVertical: s } = e, i = t.getEl();
    return i ? s ? i.clientHeight : i.clientWidth : 0;
  }
  isLayoutVertical(e) {
    var s;
    if ((s = this.config) != null && s.isParentVertical) return this.config.isParentVertical(e);
    const t = ne(e.componentRow, X.CSS_FLEX_DIRECTION, !0);
    return t === "column" || t === "column-reverse";
  }
};
X.CSS_FLEX_DIRECTION = "flex-direction";
let J = X;
const _ = class _ {
  constructor(e) {
    this.config = e;
  }
  getSize(e) {
    var s;
    if ((s = this.config) != null && s.getSize) return this.config.getSize(e);
    const t = e.componentColumn;
    if (t.is(_.MJML_COLUMN_TYPE)) {
      const a = t.getAttributes().width;
      if (a && (a.includes("%") || !isNaN(parseFloat(a))))
        return parseFloat(a);
      const o = t.parent();
      return 100 / (o ? o.components().length : 1);
    }
    return 0;
  }
  setSize(e) {
    var t;
    if ((t = this.config) != null && t.setSize)
      this.config.setSize(e);
    else {
      const { componentColumn: s, sizeValue: i, partial: a } = e;
      s.is(_.MJML_COLUMN_TYPE) && s.addAttributes({ width: `${parseFloat(i)}%` }, { partial: a });
    }
  }
};
_.MJML_COLUMN_TYPE = "mj-column";
let q = _;
const Y = class Y {
  constructor(e) {
    this.config = e;
  }
  isGapSupported() {
    return !1;
  }
  getGap(e) {
    var s;
    if ((s = this.config) != null && s.getGap) return this.config.getGap(e);
    const { componentRow: t } = e;
    if (t.is(Y.MJML_SECTION_TYPE)) {
      const i = t.getAttributes();
      if (i && i.padding)
        return parseInt(i.padding, 10) || 0;
    }
    return 0;
  }
  setGap(e) {
    var t, s;
    (s = (t = this.config) == null ? void 0 : t.setGap) == null || s.call(t, e);
  }
};
Y.MJML_SECTION_TYPE = "mj-section";
let Z = Y;
class $e {
  constructor(e) {
    this.config = e;
  }
  getParentSize(e) {
    var o;
    if ((o = this.config) != null && o.getParentSize) return this.config.getParentSize(e);
    const { componentRow: t, isVertical: s } = e, i = t.getEl();
    if (!i) return 0;
    let a = i;
    if (i.tagName !== "TABLE") {
      const l = i.querySelectorAll("table");
      l.length && (a = l[0]);
    }
    return s ? a.clientHeight : a.clientWidth;
  }
  isLayoutVertical(e) {
    var t;
    return (t = this.config) != null && t.isParentVertical ? this.config.isParentVertical(e) : !1;
  }
}
class A {
  constructor() {
    this.handlerCache = /* @__PURE__ */ new Map();
  }
  static getInstance() {
    return A.instance || (A.instance = new A()), A.instance;
  }
  getHandlers(e) {
    const t = `${e.projectType}-${e.disableGapHandler ? "nogap" : "gap"}`;
    return this.handlerCache.has(t) || (H(e) ? this.handlerCache.set(t, {
      sizeHandler: new q(e),
      gapHandler: new Z(e),
      parentSizeHandler: new $e(e)
    }) : this.handlerCache.set(t, {
      sizeHandler: new W(e),
      gapHandler: new K(e),
      parentSizeHandler: new J(e)
    })), this.handlerCache.get(t);
  }
}
function E(n) {
  return A.getInstance().getHandlers(n);
}
const ae = (n) => {
  n.style.display = "none";
}, oe = (n) => {
  n.style.display = "block";
}, M = (n) => +parseFloat(`${n}`).toFixed(2), H = (n) => n.projectType === ue.email, Ae = (n) => n ? ["top", "bottom"] : ["left", "right"], He = (n) => {
  const e = n.parent();
  return e ? e.components().models.indexOf(n) === 0 : !1;
}, Me = (n) => {
  const e = n.parent();
  if (!e) return !1;
  const t = e.components().models;
  return t.indexOf(n) === t.length - 1;
}, Ve = (n) => {
  const e = n.parent();
  if (!e) return !1;
  const t = e.components().models;
  return t.length > 1 && n.index() === t.length - 1;
}, Ne = (n, e, t, s) => {
  const a = n + (t ? e === "top" ? -1 : e === "bottom" ? 1 : 0 : e === "left" ? -1 : e === "right" ? 1 : 0);
  return a >= 0 && a < s ? a : -1;
}, k = (n) => n === "top" || n === "bottom", je = (n, e) => !!(He(n) && (e === "left" || e === "top") || Me(n) && (e === "right" || e === "bottom")), _e = (n) => {
  const e = n.parent();
  return e ? e.components().models.length > 1 : !1;
}, re = (n, e) => n === "right" || n === "bottom" ? e > 0 : e < 0, ne = (n, e, t = !1) => {
  const s = !t, i = n.getEl();
  if (!i)
    return s ? 0 : "";
  const o = window.getComputedStyle(i)[e] || "";
  if (s) {
    let l;
    return typeof o == "string" ? (l = parseFloat(o.replace(/[^-\d.]/g, "")), isNaN(l) && (l = 0)) : l = Number(o) || 0, l;
  }
  return o;
}, ce = (n, e, t) => {
  const s = Q({ componentRow: n, isVertical: e }, t), i = n.components().models;
  return s * (i.length - 1);
}, D = (n, e) => E(e).parentSizeHandler.isLayoutVertical({ componentRow: n }), B = (n, e) => E(e).sizeHandler.getSize(n), Q = (n, e) => {
  if (e != null && e.disableGapHandler) return 0;
  const { gapHandler: t, parentSizeHandler: s } = E(e);
  if (!t.isGapSupported()) return 0;
  const i = t.getGap(n), a = s.getParentSize(n);
  return i / 100 * a;
}, ee = (n, e) => E(e).parentSizeHandler.getParentSize(n), V = (n, e) => {
  E(e).sizeHandler.setSize(n);
}, fe = (n, e) => {
  const t = B(n, e);
  V({ ...n, sizeValue: `${t}%`, partial: !1 }, e);
}, me = (n, e) => {
  if (e != null && e.disableGapHandler) return;
  const { gapHandler: t } = E(e);
  t.isGapSupported() && t.setGap(n);
}, De = (n, e) => {
  const t = n.getStyle().gap;
  if (!t) return;
  const s = n.components().models, i = { componentRow: n, isVertical: D(n, e) };
  s.map((a) => fe({ ...i, componentColumn: a }, e)), me({ ...i, gapValue: String(t), partial: !1 }, e);
};
function Be(n, e) {
  const { Blocks: t } = n, { typeColumn: s, typeRow: i, blocks: a } = e;
  if (a === !1 || H(e)) return;
  const o = (u) => ({
    type: i,
    components: u.map((f) => ({
      type: s,
      style: { "flex-basis": `${f}%` }
    }))
  }), l = (u) => `<div class="gs-block-item__flex-row" style="display: flex; height: 1.75rem; width: 100%; flex-wrap: nowrap; gap: 0.5rem;">
      ${u.map((f) => `<div style="flex-basis: ${f}%; border-color: currentColor; border-width: 2px; border-radius: 0.12rem;"></div>`).join("")}
    </div>`, c = (u, f) => ({
    id: `flex-row-${f.join("-")}`,
    label: u,
    category: "Layout",
    select: !0,
    full: !0,
    attributes: { class: "gs-block-item__flex gs-utl-w-full" },
    media: l(f),
    content: o(f)
  }), g = [
    c("1 Column", [100]),
    c("2 Columns 50/50", [50, 50]),
    c("2 Columns 25/75", [25, 75]),
    c("2 Columns 75/25", [75, 25]),
    c("3 Columns", [33.33, 33.33, 33.33]),
    c("3 Columns 50/25/25", [50, 25, 25]),
    c("3 Columns 25/50/25", [25, 50, 25]),
    c("3 Columns 25/25/50", [25, 25, 50]),
    c("4 Columns", [25, 25, 25, 25]),
    c("5 Columns", [20, 20, 20, 20, 20])
  ], p = we(a) ? a({ blocks: g }) : g;
  return p.forEach((u) => t.add(u.id, u)), () => {
    p.forEach((u) => t.remove(u.id));
  };
}
const Fe = (n, e) => {
  const { Components: t } = n, { typeRow: s, typeColumn: i, extendTypeColumn: a } = e, o = `${ge}${i}`, c = !!i && !!t.getType(i) && !a;
  if (!(!i || c || H(e)))
    return t.addType(i, {
      isComponent: he(i),
      model: {
        defaults: {
          name: "Column",
          resizable: !1,
          emptyState: !0,
          classes: o,
          icon: '<svg viewBox="0 0 24 24"><path d="M14.5 2.3A1.8 1.8 0 0 0 12.7 4v16c0 1 .8 1.8 1.8 1.8h3a1.8 1.8 0 0 0 1.8-1.8V4a1.8 1.8 0 0 0-1.8-1.8zm-8 0A1.8 1.8 0 0 0 4.7 4v16c0 1 .8 1.8 1.8 1.8h3a1.8 1.8 0 0 0 1.8-1.8V4a1.8 1.8 0 0 0-1.8-1.8z"/></svg>',
          draggable: Le(s),
          attributes: { [te]: i },
          styles: `
          .${o} {
            flex-grow: 1;
          }
        `
        }
      }
    }), () => {
      t.removeType(i);
    };
}, ke = (n, e) => {
  const { Components: t } = n, { typeRow: s, typeColumn: i, extendTypeRow: a } = e, o = `${ge}${s}`, c = !!s && !!t.getType(s) && !a;
  if (!(!s || c || H(e)))
    return t.addType(s, {
      isComponent: he(s),
      model: {
        defaults: {
          name: "Row",
          classes: o,
          icon: '<svg viewBox="0 0 24 24"><path d="M4 4.8a1.8 1.8 0 0 0-1.8 1.7v3c0 1 .8 1.8 1.8 1.8h16a1.8 1.8 0 0 0 1.8-1.8v-3A1.8 1.8 0 0 0 20 4.7zm0 8a1.8 1.8 0 0 0-1.8 1.7v3c0 1 .8 1.8 1.8 1.8h16a1.8 1.8 0 0 0 1.8-1.8v-3a1.8 1.8 0 0 0-1.8-1.8z"/></svg>',
          emptyState: { styleIn: "width: 100%" },
          attributes: { [te]: s },
          droppable: Te(i),
          traits: [
            // {
            //   type: 'number',
            //   name: 'columns',
            //   label: 'Columns',
            //   min: 1,
            //   max: 12,
            //   step: 1,
            //   default: 3
            // },
            // {
            //   type: 'button',
            //   text: 'Set column count',
            //   full: true,
            //   command: (_, trait) => {
            //     const columnCount = trait.component.getTrait('columns').props().value;
            //     createEqualColumns(columnLayoutComponent, columnCount, 2);
            //   }
            // },
            {
              type: "checkbox",
              name: "snap",
              label: "Enable Snap",
              default: e.snapEnabled,
              changeProp: !0
            },
            {
              type: "number",
              name: "snap-divisions",
              label: "Snap Divisions",
              min: 1,
              max: 12,
              step: 1,
              default: e.snapDivisions,
              changeProp: !0
            }
          ],
          resizable: {
            tl: 0,
            tc: 0,
            tr: 0,
            cl: 0,
            bl: 0,
            br: 0
          },
          styles: `
          .${o} {
            display: flex;
            align-items: stretch;
            flex-wrap: nowrap;
          }
        `
        }
      }
    }), () => {
      t.removeType(s);
    };
}, Oe = "flexComponent", Xe = $.startup;
class Ye {
  constructor() {
    this.resizableChildTypes = /* @__PURE__ */ new Set(), this.gapAdjustableParentTypes = /* @__PURE__ */ new Set(), this.typeRelationships = /* @__PURE__ */ new Map();
  }
  registerResizableChild(e) {
    this.resizableChildTypes.add(e);
  }
  registerGapAdjustableParent(e) {
    this.gapAdjustableParentTypes.add(e);
  }
  registerTypeRelationship(e, t) {
    this.typeRelationships.has(e) || this.typeRelationships.set(e, /* @__PURE__ */ new Set()), this.typeRelationships.get(e).add(t), this.registerResizableChild(t), this.registerGapAdjustableParent(e);
  }
  isResizableChild(e) {
    return this.resizableChildTypes.has(e.get("type"));
  }
  isGapAdjustableParent(e) {
    return this.gapAdjustableParentTypes.has(e.get("type"));
  }
  isValidRelationship(e, t) {
    const s = e.get("type"), i = t.get("type");
    return this.typeRelationships.has(s) ? this.typeRelationships.get(s).has(i) : !1;
  }
}
class Ue {
  constructor(e, t, s) {
    this.editor = e, this.registry = t, this.opts = s, this.resizeState = /* @__PURE__ */ new WeakMap();
  }
  getState(e) {
    return this.resizeState.has(e) || this.resizeState.set(e, {}), this.resizeState.get(e);
  }
  clearState(e) {
    return this.resizeState.delete(e);
  }
  startResize(e, t, s) {
    const { opts: i } = this, a = this.getState(e);
    a.direction = t, a.startX = s.clientX, a.startY = s.clientY, a.resizing = !0, a.lastSnappedPercent = void 0;
    const o = e.parent();
    if (!o || !this.registry.isValidRelationship(o, e)) return;
    a.snapEnabled = o.get("snap") ?? i.snapEnabled, a.snapDivisions = o.get("snap-divisions") ?? i.snapDivisions ?? 12;
    const l = o.components().models, c = l.findIndex((f) => f.cid === e.cid), g = D(o, i), p = Ne(c, t, g, l.length);
    p !== -1 && (a.adjacentIdx = p);
    const u = { componentColumn: e, componentRow: o, isVertical: g };
    if (a.startPercent = B(u, i), typeof a.adjacentIdx < "u") {
      const f = l[a.adjacentIdx];
      a.neighborStartPercent = B({ ...u, componentColumn: f }, i);
    }
  }
  updateResizeByDelta(e, t, s) {
    const i = this.getState(e), a = e.parent();
    !i.resizing || !a || (i.snapEnabled ? this.updateSnapResize(e, t, s) : this.updateContinuesResize(e, t, s));
  }
  finishResize(e) {
    const t = e.parent(), s = t == null ? void 0 : t.components().models, i = { componentRow: t, isVertical: !!t && D(t, this.opts) };
    s == null || s.forEach((a) => fe({ ...i, componentColumn: a }, this.opts)), this.clearState(e);
  }
  updateContinuesResize(e, t, s) {
    const i = this.getState(e), a = e.parent(), { opts: o } = this;
    if (!a) return;
    const l = o.minItemPercent ?? 0, c = k(t), g = ee({ componentRow: a, isVertical: c }, o), p = ce(a, c, this.opts), f = 100 - p / g * 100, I = s / (g - p) * f, { startPercent: P = 0, neighborStartPercent: y = 0 } = i, v = { componentRow: a, isVertical: c, componentColumn: e, partial: !0 }, R = re(t, s) ? P + Math.abs(I) : P - Math.abs(I);
    if (typeof i.adjacentIdx < "u") {
      const z = a.components().models[i.adjacentIdx], x = P + y, b = x - l, r = Math.min(b, Math.max(l, R)), d = x - r;
      V({ ...v, sizeValue: `${M(r)}%` }, o), V(
        { ...v, componentColumn: z, sizeValue: `${M(d)}%` },
        o
      );
    } else {
      const z = Math.max(l, Math.min(f, R));
      V({ ...v, sizeValue: `${M(z)}%` }, o);
    }
  }
  updateSnapResize(e, t, s) {
    const i = this.getState(e), a = e.parent(), o = k(t), l = ee({ componentRow: a, isVertical: o }, this.opts), c = ce(a, o, this.opts), g = l - c, p = s / g * 100, u = re(t, s), { startPercent: f = 0, snapDivisions: I = 12 } = i, P = u ? f + Math.abs(p) : f - Math.abs(p), y = 100 / I, v = Math.floor(P / y) * y, R = Math.ceil(P / y) * y, z = Math.abs(R - P), x = Math.abs(P - v), b = y * 0.2, C = z < x ? R : v;
    if (C > 0 && C < 100 && (z < b || x < b) && i.lastSnappedPercent !== C) {
      i.lastSnappedPercent = C;
      let m = Math.abs(C - f) / 100 * g;
      (u && (t === "left" || t === "top") || !u && (t === "right" || t === "bottom")) && (m = -m), this.updateContinuesResize(e, t, m);
    } else z >= b && x >= b && (i.lastSnappedPercent = void 0);
  }
}
class We {
  constructor(e, t, s) {
    this.editor = e, this.registry = t, this.opts = s;
  }
  updateGapByDelta(e, t, s, i) {
    if (!this.registry.isGapAdjustableParent(e)) return;
    const { opts: a } = this, o = Math.max(0, s + t), l = ee({ componentRow: e, isVertical: i }, a), c = o / l * 100, g = e.components().models, p = g.length - 1, u = { componentRow: e, isVertical: i }, f = g.reduce(
      (b, C) => b + B({ ...u, componentColumn: C }, a),
      0
    ), P = 100 - c * p, y = a.minItemPercent || 5;
    if (P < y * g.length)
      return;
    const R = 100 - p * c, z = f - R, x = { componentRow: e, isVertical: i, partial: !0 };
    g.map((b) => {
      const C = B({ ...u, componentColumn: b }, a), r = C - C / f * z;
      V({ ...x, componentColumn: b, sizeValue: `${M(r)}%` }, a);
    }), me({ ...x, gapValue: `${M(c)}%` }, a);
  }
  finishGapAdjust(e) {
    De(e, this.opts);
  }
}
class Ke {
  constructor(e, t, s) {
    this.editor = e, this.registry = t, this.opts = s, this.resizeHandler = new Ue(e, t, s), this.gapHandler = new We(e, t, s);
  }
  startResize(e, t, s) {
    this.resizeHandler.startResize(e, t, s);
  }
  updateResizeByDelta(e, t, s) {
    this.resizeHandler.updateResizeByDelta(e, t, s);
  }
  finishResize(e) {
    this.resizeHandler.finishResize(e);
  }
  updateGapByDelta(e, t, s, i) {
    this.gapHandler.updateGapByDelta(e, t, s, i);
  }
  finishGapAdjust(e) {
    this.gapHandler.finishGapAdjust(e);
  }
  canResize(e) {
    const t = e.parent();
    return t ? this.registry.isValidRelationship(t, e) : !1;
  }
  canAdjustGap(e) {
    return this.registry.isGapAdjustableParent(e);
  }
}
const O = "gs-flex-spots", le = `${O}__handle-size`, Je = `${O}__handle-gap`;
function qe(n, e) {
  const { Canvas: t } = n, s = "flex-resize-spot";
  let i, a, o, l, c = null, g = null;
  const p = new Ye(), u = new Ke(n, p, e), f = () => {
    var r;
    i = document.createElement("div"), i.className = O, i.style.display = "none", a = document.createElement("div"), a.className = `${O}__handles`, a.style.position = "absolute", a.style.pointerEvents = "none", a.style.zIndex = "21", o = {
      left: document.createElement("div"),
      right: document.createElement("div"),
      top: document.createElement("div"),
      bottom: document.createElement("div")
    }, Object.entries(o).forEach(([d, m]) => {
      const S = d, h = k(S);
      m.className = `${le} ${le}-${S} gjs-resizer-h gjs-cv-unscale`, m.style.cssText = `
        pointer-events: all;
        position: absolute;
        z-index: 1;
        cursor: ${h ? "ns-resize" : "ew-resize"};
        ${h ? "left: 50%;" : "top: 50%;"}
        ${S === "left" ? "left: 0px;" : ""}
        ${S === "right" ? "right: 0px;" : ""}
        ${S === "top" ? "top: 0px;" : ""}
        ${S === "bottom" ? "bottom: 0px;" : ""}
      `, m.addEventListener("pointerdown", I(S)), a.appendChild(m);
    }), !e.disableGapHandler && !H(e) && (l = document.createElement("div"), l.className = Je, l.style.cssText = `
        position: absolute;
        background-color: var(--gs-theme-cl-cmp-bg1, #3b97e3);
        border-width: 2px;
        border-radius: 9999px;
        border-color: #fff;
        box-sizing: content-box;
        pointer-events: all;
        max-width: 3rem;
        max-height: 3rem;
      `, l.addEventListener("pointerdown", P()), a.appendChild(l)), i.append(a), (r = t.getSpotsEl()) == null || r.appendChild(i);
  }, I = (r) => (d) => {
    if (!c) return;
    d.stopPropagation(), d.preventDefault(), u.startResize(c, r, d);
    const m = d.clientX, S = d.clientY;
    d.target.setPointerCapture(d.pointerId);
    const h = (T) => {
      const G = n.Canvas.getZoomMultiplier(), L = (T.clientX - m) * G, F = (T.clientY - S) * G, U = k(r) ? F : L;
      u.updateResizeByDelta(c, r, U);
    }, w = () => {
      u.finishResize(c), d.target.releasePointerCapture(d.pointerId), document.removeEventListener("pointermove", h), document.removeEventListener("pointerup", w);
    };
    document.addEventListener("pointermove", h), document.addEventListener("pointerup", w);
  }, P = () => (r) => {
    if (!g) return;
    const d = g;
    r.stopPropagation(), r.preventDefault();
    const m = D(d, e), S = Q({ componentRow: d, isVertical: m }, e), h = r.clientX, w = r.clientY;
    r.target.setPointerCapture(r.pointerId);
    const T = (L) => {
      const F = n.Canvas.getZoomMultiplier(), U = m ? (L.clientY - w) * F : (L.clientX - h) * F;
      u.updateGapByDelta(d, U, S, m);
    }, G = () => {
      u.finishGapAdjust(d), r.target.releasePointerCapture(r.pointerId), document.removeEventListener("pointermove", T), document.removeEventListener("pointerup", G);
    };
    document.addEventListener("pointermove", T), document.addEventListener("pointerup", G);
  }, y = (r) => {
    const d = r.component;
    if (!d || !i || (c = d, g = d.parent(), !g)) return;
    const m = g;
    oe(i);
    const S = r.getStyle();
    a && Object.assign(a.style, S);
    const h = D(m, e), w = Ae(h);
    if (Object.values(o).forEach(ae), w.forEach((G) => {
      if (je(d, G)) return;
      const L = o[G];
      oe(L);
    }), E(e).gapHandler.isGapSupported() && l && _e(d)) {
      const G = Q({ componentRow: m, isVertical: h }, e);
      v(G, h, Ve(d));
    }
  }, v = (r, d, m = !1) => {
    const S = e.gapHandleSize, h = l.style;
    if (d) {
      h.height = `${S}px`;
      const w = l.offsetHeight;
      m ? (h.top = `-${(r + w) / 2}px`, h.bottom = "") : (h.bottom = `-${(r + w) / 2}px`, h.top = ""), h.width = "50%", h.left = "50%", h.transform = "translateX(-50%)", h.cursor = "row-resize";
    } else {
      h.width = `${S}px`;
      const w = l.offsetWidth;
      m ? (h.left = `-${(r + w) / 2}px`, h.right = "") : (h.right = `-${(r + w) / 2}px`, h.left = ""), h.height = "50%", h.top = "50%", h.transform = "translateY(-50%)", h.cursor = "col-resize";
    }
  }, R = () => {
    i && (ae(i), c = null, g = null);
  }, z = () => {
    t.removeSpots({ type: s });
    const r = n.getSelected(), d = r == null ? void 0 : r.parent();
    r && d && p.isValidRelationship(d, r) ? t.addSpot({ type: s, component: r }) : R();
  }, x = () => {
    const r = t.getSpots().filter((d) => d.type === s)[0];
    r && y(r);
  }, b = (r, d) => {
    p.registerTypeRelationship(r, d);
  };
  n.onReady(() => {
    f(), H(e) ? b("mj-section", "mj-column") : b(e.typeRow, e.typeColumn);
  });
  const C = "component:toggled";
  return n.on(t.events.spot, x), n.on(C, z), () => {
    n.off(t.events.spot, x), n.off(C, z);
  };
}
const Ze = function(n, e = {}) {
  const t = {
    typeRow: "flex-row",
    typeColumn: "flex-column",
    gapHandleSize: 3,
    snapDivisions: 12,
    minItemPercent: 5,
    ...e
  }, s = [ke(n, t), Fe(n, t)], i = qe(n, t), a = Be(n, t);
  Ge({
    editor: n,
    licenseKey: t.licenseKey,
    plan: Xe,
    pluginName: Oe,
    cleanup: () => {
      s.forEach((o) => o == null ? void 0 : o()), i(), a == null || a();
    }
  });
}, Qe = Re(Ze);
export {
  Qe as default
};
