import { jsx as y } from "react/jsx-runtime";
import { useState as N, useEffect as _, createElement as B, Fragment as T } from "react";
import { createRoot as $ } from "react-dom/client";
const I = "app.grapesjs.com", U = "app-stage.grapesjs.com", K = "app2.grapesjs.com", F = "app-stage2.grapesjs.com", P = [
  I,
  K,
  U,
  F,
  "localhost",
  "127.0.0.1",
  ".local-credentialless.webcontainer.io",
  // For stackblitz.com demos
  ".local.webcontainer.io",
  // For stackblitz.com demos
  "-sandpack.codesandbox.io"
  // For Sandpack demos
], M = "license:check:start", V = "license:check:end", z = () => typeof window < "u", G = ({ isDev: e, isStage: t }) => `${e ? "" : `https://${t ? U : I}`}/api`, J = () => {
  const e = z() && window.location.hostname;
  return !!e && (P.includes(e) || P.some((t) => e.endsWith(t)));
}, q = (e) => e.replace(/[A-Z]+(?![a-z])|[A-Z]/g, (t, n) => (n ? "-" : "") + t.toLowerCase()), x = (e) => typeof e == "string";
function H(e) {
  return typeof e == "function";
}
async function Z({
  path: e,
  baseApiUrl: t,
  method: n = "GET",
  headers: s = {},
  params: r,
  body: o
}) {
  const c = `${t || G({ isDev: !1, isStage: !1 })}${e}`, i = {
    method: n,
    headers: {
      "Content-Type": "application/json",
      ...s
    }
  };
  o && (i.body = JSON.stringify(o));
  const f = r ? new URLSearchParams(r).toString() : "", l = f ? `?${f}` : "", d = await fetch(`${c}${l}`, i);
  if (!d.ok)
    throw new Error(`HTTP error! status: ${d.status}`);
  return d.json();
}
var v = /* @__PURE__ */ ((e) => (e.free = "free", e.startup = "startup", e.business = "business", e.enterprise = "enterprise", e))(v || {});
const O = {
  [v.free]: 0,
  [v.startup]: 10,
  [v.business]: 20,
  [v.enterprise]: 30
};
function Q(e) {
  const t = e;
  return t.init = (n) => (s) => e(s, n), t;
}
const X = (e) => /* @__PURE__ */ Q(e);
async function Y({
  editor: e,
  plan: t,
  pluginName: n,
  licenseKey: s,
  cleanup: r
}) {
  let o = "", a = !1;
  const c = J(), i = (l) => {
    console.warn("Cleanup plugin:", n, "Reason:", l), r();
  }, f = (l = {}) => {
    var h;
    const { error: d, sdkLicense: m } = l, u = (h = l.plan) == null ? void 0 : h.category;
    if (!(m || l.license) || d)
      i(d || "Invalid license");
    else if (u) {
      const b = O[t], C = O[u];
      b > C && i({ pluginRequiredPlan: t, licensePlan: u });
    }
  };
  e.on(M, (l) => {
    o = l == null ? void 0 : l.baseApiUrl, a = !0;
  }), e.on(V, (l) => {
    f(l);
  }), setTimeout(async () => {
    if (!a) {
      if (c) return;
      if (s) {
        const l = await ee({ licenseKey: s, pluginName: n, baseApiUrl: o });
        l && f(l);
      } else
        i("The `licenseKey` option not provided");
    }
  }, 2e3);
}
async function ee(e) {
  const { licenseKey: t, pluginName: n, baseApiUrl: s } = e;
  try {
    return (await Z({
      baseApiUrl: s,
      path: `/sdk/${t || "na"}`,
      method: "POST",
      params: {
        d: window.location.hostname,
        pn: n
      }
    })).result || {};
  } catch (r) {
    return console.error("Error during SDK license check:", r), !1;
  }
}
function te(e) {
  const t = {};
  for (const n in e)
    if (Object.prototype.hasOwnProperty.call(e, n)) {
      const s = q(n);
      t[s] = e[n];
    }
  return t;
}
const ne = (e, t) => {
  const n = e.components || {};
  for (const s in n) {
    const r = n[s];
    if (r.component === t)
      return { cmpConfig: r, type: s };
  }
};
function L(e) {
  const t = {};
  let n = !1;
  for (const s in e)
    if (Object.prototype.hasOwnProperty.call(e, s)) {
      const r = e[s];
      if (typeof r == "string" || typeof r == "number") {
        const o = s.includes("-") ? s.replace(/-([a-z])/g, (a) => a[1].toUpperCase()) : s;
        t[o] = r, n = !0;
      }
    }
  return n ? t : void 0;
}
function oe(e) {
  const t = {};
  return e.split(";").forEach((n) => {
    if (!n.trim()) return;
    const s = n.indexOf(":");
    if (s > 0) {
      const r = n.substring(0, s).trim(), o = n.substring(s + 1).trim();
      if (r && o) {
        const a = r.replace(/-([a-z])/g, (c) => c[1].toUpperCase());
        t[a] = o;
      }
    }
  }), Object.keys(t).length > 0 ? t : void 0;
}
function se(e) {
  if (e) {
    if (typeof e == "object" && !Array.isArray(e))
      return L(e);
    if (typeof e == "string") {
      let t = oe(e);
      if (!t)
        try {
          const n = JSON.parse(e);
          typeof n == "object" && n !== null && !Array.isArray(n) && (t = L(n));
        } catch (n) {
          console.error("Failed to parse style string as JSON", n);
        }
      return t;
    }
    if (Array.isArray(e)) {
      const t = {};
      return e.forEach((n) => {
        if (typeof n == "object" && n !== null) {
          const s = n.name || n.property, r = n.value;
          if (typeof s == "string" && s && r !== void 0 && r !== "") {
            const o = s.replace(/-([a-z])/g, (a) => a[1].toUpperCase());
            t[o] = r;
          }
        }
      }), Object.keys(t).length > 0 ? t : void 0;
    }
  }
}
function re(e) {
  return D[e] ? D[e] : e.includes("-") ? e.replace(/-([a-z])/g, (t, n) => n.toUpperCase()) : e;
}
function ce(e) {
  var n;
  const t = {};
  for (const [s, r] of Object.entries(e))
    if (s === "style")
      t.style = se(r);
    else if (s.startsWith("data-"))
      t[s] = r;
    else {
      const o = re(s);
      ((n = e.xmlns) == null ? void 0 : n.includes("svg")) || e.viewBox !== void 0 || e.d !== void 0 || ie.has(o) || o.startsWith("svg") ? t[o] = r : !ae.has(o) && !o.startsWith("on") && !o.startsWith("aria-") && !o.startsWith("data-") ? t[s] = r : t[o] = r;
    }
  return t;
}
const ae = /* @__PURE__ */ new Set([
  "className",
  "id",
  "style",
  "href",
  "src",
  "alt",
  "title",
  "target",
  "rel",
  "type",
  "name",
  "value",
  "placeholder",
  "onClick",
  "onChange",
  "onSubmit",
  "onBlur",
  "onFocus",
  "disabled",
  "readOnly",
  "checked",
  "selected",
  "multiple",
  "width",
  "height",
  "maxLength",
  "min",
  "max",
  "step",
  "rows",
  "cols",
  "autoComplete",
  "autoFocus",
  "required",
  "spellCheck",
  "tabIndex",
  "aria-label",
  "aria-labelledby",
  "aria-describedby",
  "role"
]), ie = /* @__PURE__ */ new Set([
  "x",
  "y",
  "d",
  "cx",
  "cy",
  "r",
  "rx",
  "ry",
  "x1",
  "x2",
  "y1",
  "y2",
  "points",
  "fill",
  "stroke",
  "strokeWidth",
  "strokeLinecap",
  "strokeLinejoin",
  "strokeDasharray",
  "strokeOpacity",
  "fillOpacity",
  "fillRule",
  "clipRule",
  "transform",
  "viewBox",
  "preserveAspectRatio",
  "pathLength",
  "vectorEffect",
  "dominantBaseline",
  "alignmentBaseline",
  "textAnchor",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "textDecoration",
  "baselineShift",
  "opacity",
  "mask",
  "clipPath",
  "overflow",
  "pointerEvents"
]), D = {
  class: "className",
  for: "htmlFor",
  "http-equiv": "httpEquiv",
  "accept-charset": "acceptCharset",
  "stroke-width": "strokeWidth",
  "stroke-linecap": "strokeLinecap",
  "stroke-linejoin": "strokeLinejoin",
  "fill-rule": "fillRule",
  "clip-rule": "clipRule",
  "stroke-miterlimit": "strokeMiterlimit",
  "stroke-dasharray": "strokeDasharray",
  "stroke-opacity": "strokeOpacity",
  "fill-opacity": "fillOpacity",
  "font-family": "fontFamily",
  "font-size": "fontSize",
  "text-anchor": "textAnchor"
}, R = (e) => (e == null ? void 0 : e.$$typeof) && typeof e.props == "object";
function le(e) {
  return (t) => {
    const n = t.getContent();
    R(n) && t.set({
      content: w({ ...e, model: n }),
      reactContent: n
    });
  };
}
const pe = (e) => (t) => {
  const n = t.component;
  R(n) && (t.component = { components: w({ ...e, model: n }) });
};
function w(e) {
  const { model: t, editor: n, config: s } = e;
  if (R(t)) {
    const r = t, o = {}, { type: a, props: c = {} } = r, { children: i, className: f, style: l, ...d } = c, m = (p) => ({ type: "textnode", content: p }), u = typeof a == "symbol";
    if (H(a)) {
      const p = ne(s, a);
      o.type = p == null ? void 0 : p.type;
    } else n.Components.getType(a) ? o.type = a : u || (o.tagName = a);
    if (f && (o.classes = f), l && (o.style = te(l)), Array.isArray(i) ? o.components = i.map((p) => x(p) ? m(p) : w({ ...e, model: p })).filter(Boolean) : x(i) && (o.components = m(i)), Object.keys(d).length) {
      const p = n.Parser.parserHtml.splitPropsFromAttr(d);
      o.attributes = p.attrs, Object.assign(o, p.props);
    }
    return o;
  }
}
function fe(e) {
  const { component: t } = e, [n, s] = N(0), [r, o] = N();
  return _(() => {
    if (!t) return () => {
    };
    const c = () => s((p) => p + 1), i = () => {
      [...t.views].forEach((h) => h.remove()), o(void 0);
    }, { em: f } = t, l = f.Components.events, m = [...["components", "attributes", "classes"].map((p) => `${l.update}:${p}`), "rerender"].join(" "), u = [l.removed, "rerender"].join(" ");
    return t.on(m, c), t.on(u, i), () => {
      t.off(m, c), t.off(u, i), i();
    };
  }, [t]), { key: n, view: r, connectDom: (c) => {
    if (!c) return;
    const i = ue({ ...e, el: c });
    o(i);
  } };
}
function ue(e) {
  var i;
  const { editor: t, component: n, el: s, frameView: r } = e, { em: o, Components: a } = t;
  let c = n.getView(r.model);
  if ((c == null ? void 0 : c.el) === s)
    return c;
  if (!c) {
    const { ComponentView: f } = a, l = n.attributes.type || "default", d = ((i = a.getType(l)) == null ? void 0 : i.view) || f, m = { ...a.config, frameView: r, em: o }, u = d.extend({
      initComponents() {
      },
      _createElement() {
        return s;
      },
      _removeElement() {
      },
      __clearAttributes() {
      },
      render() {
        var p;
        return this._ensureElement(), this._setData(), this.renderAttributes(), (p = this.updateSrc) == null || p.call(this), this;
      }
    });
    c = new u({ el: s, config: m, model: n });
  }
  return c.el = s, c.render(), c;
}
function de(e, t) {
  const { Components: n } = e, s = (r) => {
    const { id: o, model: a } = r;
    n.addType(o, {
      model: {
        toJSON(...c) {
          const i = a.prototype.toJSON.apply(this, c);
          return i.tagName = this.tagName, i;
        }
      }
    });
  };
  n.getTypes().forEach(s), e.on("component:type:add", s), Object.entries(t.components || {}).forEach(([r, o]) => {
    var m, u;
    const { allowPropClassName: a, allowPropId: c, allowChildren: i } = o, f = !c && !a, l = () => ({
      disabled: f
    }), d = () => ({
      disableClasses: !a,
      disableComponent: !c
    });
    n.addType(r, {
      isComponent: (p) => (p == null ? void 0 : p.tagName) === r,
      model: {
        defaults: {
          type: r,
          traits: ((m = o.props) == null ? void 0 : m.call(o)) || [],
          droppable: !!i,
          stylable: !f,
          styleManager: l,
          selectorManager: d,
          ...((u = o.model) == null ? void 0 : u.defaults) || {}
        }
      }
    });
  });
}
function W(e) {
  var S;
  const { component: t, config: n, editor: s, frameView: r, onMount: o, tagName: a, children: c } = e, { key: i, view: f, connectDom: l } = fe(e);
  _(() => {
    if (!f && !o) return;
    const g = setTimeout(() => {
      f && (o == null || o(f), setTimeout(() => f.postRender()));
    });
    return () => clearTimeout(g);
  }, [f]);
  const d = t.get("type") || "default", m = t.content, u = (S = n.components) == null ? void 0 : S[d], p = (u == null ? void 0 : u.component) || a || t.tagName || "div", h = t.components(), b = h.length ? h.map((g) => /* @__PURE__ */ y(W, { component: g, config: n, editor: s, frameView: r }, g.cid)) : [m || void 0], C = ce(t.getAttributes()), A = u == null ? void 0 : u.editorRender, E = [...b, c].filter((g) => g ?? !1), k = E.length ? E : null;
  if (A)
    return /* @__PURE__ */ y(A, { props: C, editor: s, component: t, connectDom: l, children: k });
  if (u != null && u.component)
    return /* @__PURE__ */ y("gjs-wrapper", { ref: l, style: u.wrapperStyle, children: /* @__PURE__ */ y(p, { ...C, children: k }) });
  if (t.isInstanceOf("textnode"))
    return m;
  const j = t.isInstanceOf("text") ? i : void 0;
  return /* @__PURE__ */ B(p, { ...C, ref: l, key: j }, t.get("void") ? null : k);
}
const me = (e) => {
  const { frame: t, window: n, onMount: s, editor: r } = e, o = r.Canvas.events, { root: a } = t;
  try {
    const c = $(n.document.body);
    c.render(/* @__PURE__ */ y(ye, { ...e, component: a, onMount: s }));
    const i = () => c.unmount();
    t.once(o.frameUnload, i), n.addEventListener("unload", i);
  } catch (c) {
    console.warn(c);
  }
  return a.getView();
};
function ye(e) {
  const { editor: t, component: n, window: s, frameView: r, config: o, onMount: a } = e, c = s.document, i = o.rootComponent || T, f = o.rootComponent ? { editorProps: { doc: c, editor: t, frameView: r } } : {}, l = (o == null ? void 0 : o.bodyAfter) || T;
  return /* @__PURE__ */ y(i, { ...f, children: /* @__PURE__ */ y(
    W,
    {
      tagName: "div",
      component: n,
      config: o,
      editor: t,
      frameView: r,
      onMount: a,
      children: /* @__PURE__ */ y(l, { ...f })
    }
  ) });
}
const he = "rendererReact", ge = v.startup, ve = function(e, t = {}) {
  const { Blocks: n, Pages: s } = e, r = n.events, o = s.events;
  e.Canvas.config.customRenderer = (c) => me({ ...c, config: t }), e.Components.config.processor = (c) => w({ model: c, editor: e, config: t }), de(e, t);
  const a = [
    [r.add, le({ editor: e, config: t })],
    [o.addBefore, pe({ editor: e, config: t })]
  ];
  a.forEach(([c, i]) => e.on(c, i)), Y({
    editor: e,
    licenseKey: t.licenseKey,
    plan: ge,
    pluginName: he,
    cleanup: () => {
      e.Canvas.config.customRenderer = void 0, e.Components.config.processor = void 0, a.forEach(([c, i]) => e.off(c, i));
    }
  });
}, ke = X(ve);
export {
  ke as default
};
