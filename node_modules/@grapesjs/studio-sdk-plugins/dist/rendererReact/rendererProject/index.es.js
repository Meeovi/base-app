import { jsx as l, jsxs as C } from "react/jsx-runtime";
import { createElement as T, Fragment as v } from "react";
var m = /* @__PURE__ */ ((n) => (n.NoPagesFound = "noPagesFound", n.PageNotFound = "pageNotFound", n.NoFramesFound = "noFramesFound", n.MissingRootComponent = "missingRootComponent", n.ComponentNotFound = "componentNotFound", n))(m || {});
function k(n) {
  const { config: t, errorType: e } = n, r = t == null ? void 0 : t.errorComponent;
  return r ? /* @__PURE__ */ l(r, { ...n }) : /* @__PURE__ */ C("div", { children: [
    "Error: ",
    e
  ] });
}
function P(n) {
  const t = {};
  let e = !1;
  for (const r in n)
    if (Object.prototype.hasOwnProperty.call(n, r)) {
      const s = n[r];
      if (typeof s == "string" || typeof s == "number") {
        const o = r.includes("-") ? r.replace(/-([a-z])/g, (i) => i[1].toUpperCase()) : r;
        t[o] = s, e = !0;
      }
    }
  return e ? t : void 0;
}
function D(n) {
  const t = {};
  return n.split(";").forEach((e) => {
    if (!e.trim()) return;
    const r = e.indexOf(":");
    if (r > 0) {
      const s = e.substring(0, r).trim(), o = e.substring(r + 1).trim();
      if (s && o) {
        const i = s.replace(/-([a-z])/g, (c) => c[1].toUpperCase());
        t[i] = o;
      }
    }
  }), Object.keys(t).length > 0 ? t : void 0;
}
function W(n) {
  if (n) {
    if (typeof n == "object" && !Array.isArray(n))
      return P(n);
    if (typeof n == "string") {
      let t = D(n);
      if (!t)
        try {
          const e = JSON.parse(n);
          typeof e == "object" && e !== null && !Array.isArray(e) && (t = P(e));
        } catch (e) {
          console.error("Failed to parse style string as JSON", e);
        }
      return t;
    }
    if (Array.isArray(n)) {
      const t = {};
      return n.forEach((e) => {
        if (typeof e == "object" && e !== null) {
          const r = e.name || e.property, s = e.value;
          if (typeof r == "string" && r && s !== void 0 && s !== "") {
            const o = r.replace(/-([a-z])/g, (i) => i[1].toUpperCase());
            t[o] = s;
          }
        }
      }), Object.keys(t).length > 0 ? t : void 0;
    }
  }
}
function B(n) {
  return j[n] ? j[n] : n.includes("-") ? n.replace(/-([a-z])/g, (t, e) => e.toUpperCase()) : n;
}
function I(n) {
  var e;
  const t = {};
  for (const [r, s] of Object.entries(n))
    if (r === "style")
      t.style = W(s);
    else if (r.startsWith("data-"))
      t[r] = s;
    else {
      const o = B(r);
      ((e = n.xmlns) == null ? void 0 : e.includes("svg")) || n.viewBox !== void 0 || n.d !== void 0 || z.has(o) || o.startsWith("svg") ? t[o] = s : !M.has(o) && !o.startsWith("on") && !o.startsWith("aria-") && !o.startsWith("data-") ? t[r] = s : t[o] = s;
    }
  return t;
}
const M = /* @__PURE__ */ new Set([
  "className",
  "id",
  "style",
  "href",
  "src",
  "alt",
  "title",
  "target",
  "rel",
  "type",
  "name",
  "value",
  "placeholder",
  "onClick",
  "onChange",
  "onSubmit",
  "onBlur",
  "onFocus",
  "disabled",
  "readOnly",
  "checked",
  "selected",
  "multiple",
  "width",
  "height",
  "maxLength",
  "min",
  "max",
  "step",
  "rows",
  "cols",
  "autoComplete",
  "autoFocus",
  "required",
  "spellCheck",
  "tabIndex",
  "aria-label",
  "aria-labelledby",
  "aria-describedby",
  "role"
]), z = /* @__PURE__ */ new Set([
  "x",
  "y",
  "d",
  "cx",
  "cy",
  "r",
  "rx",
  "ry",
  "x1",
  "x2",
  "y1",
  "y2",
  "points",
  "fill",
  "stroke",
  "strokeWidth",
  "strokeLinecap",
  "strokeLinejoin",
  "strokeDasharray",
  "strokeOpacity",
  "fillOpacity",
  "fillRule",
  "clipRule",
  "transform",
  "viewBox",
  "preserveAspectRatio",
  "pathLength",
  "vectorEffect",
  "dominantBaseline",
  "alignmentBaseline",
  "textAnchor",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "textDecoration",
  "baselineShift",
  "opacity",
  "mask",
  "clipPath",
  "overflow",
  "pointerEvents"
]), j = {
  class: "className",
  for: "htmlFor",
  "http-equiv": "httpEquiv",
  "accept-charset": "acceptCharset",
  "stroke-width": "strokeWidth",
  "stroke-linecap": "strokeLinecap",
  "stroke-linejoin": "strokeLinejoin",
  "fill-rule": "fillRule",
  "clip-rule": "clipRule",
  "stroke-miterlimit": "strokeMiterlimit",
  "stroke-dasharray": "strokeDasharray",
  "stroke-opacity": "strokeOpacity",
  "fill-opacity": "fillOpacity",
  "font-family": "fontFamily",
  "font-size": "fontSize",
  "text-anchor": "textAnchor"
};
function L(n, t, e) {
  const { id: r, type: s } = n, o = r || void 0;
  let i;
  return r ? i = r : t ? i = `${t}-${e ?? 0}` : s === "head" ? i = "gjs-head" : t === "gjs-head" ? i = `${t}-${e ?? 0}` : i = `gjs-${s}`, { key: i, nodeId: o };
}
const R = function n(t) {
  var w;
  const { component: e, config: r, children: s, parentId: o, index: i } = t;
  if (!e) return null;
  const { type: c, content: a } = e;
  if (c === "textnode") return a;
  const u = (w = r == null ? void 0 : r.components) == null ? void 0 : w[c], d = (u == null ? void 0 : u.component) || e.tagName || "div", h = e.attributes, { key: g, nodeId: N } = L(e, o, i), b = !!(u != null && u.component), A = I(h);
  b && Object.keys(A).forEach((y) => {
    const p = A[y];
    typeof p == "string" && !isNaN(Number(p)) && p.trim() !== "" && (A[y] = Number(p));
  });
  const { components: F } = e, x = [...F.length ? F.map((y, p) => /* @__PURE__ */ l(n, { config: r, component: y, parentId: g, index: p }, `${y.id}-${p}`)) : [a], s], $ = {
    ...A,
    ...N ? { id: N } : {}
  };
  return b ? /* @__PURE__ */ l(d, { ...$, children: x }, g) : /* @__PURE__ */ T(d, { ...$, key: g }, e.isVoid ? null : x);
};
function U(n) {
  var a;
  const { config: t, root: e, css: r } = n, s = (t == null ? void 0 : t.rootComponent) || v, o = ((a = e.docEl) == null ? void 0 : a.tagName) || "html", i = (t == null ? void 0 : t.headAfter) || v, c = (t == null ? void 0 : t.bodyAfter) || v;
  return /* @__PURE__ */ l(o, { children: /* @__PURE__ */ C(s, { children: [
    /* @__PURE__ */ C(R, { component: e.head, config: t, children: [
      /* @__PURE__ */ l("style", { children: `${r}` }),
      /* @__PURE__ */ l(i, {})
    ] }),
    /* @__PURE__ */ l(R, { component: e, config: t, children: /* @__PURE__ */ l(c, {}) })
  ] }) });
}
class S {
  constructor(t) {
    this.data = t;
  }
  get id() {
    var t;
    return (t = this.data.attributes) == null ? void 0 : t.id;
  }
  get type() {
    return this.data.type || "default";
  }
  get tagName() {
    const { type: t } = this;
    return t === "svg" ? "svg" : t === "image" ? "img" : t === "linkBox" || t === "link" ? "a" : t === "head" ? "head" : t === "wrapper" ? "body" : this.data.tagName || "";
  }
  get isVoid() {
    return this.tagName === "img" ? !0 : !!this.data.void;
  }
  get attributes() {
    const t = { ...this.data.attributes }, { classes: e } = this;
    e.length && (t.class = e.join(" "));
    function r(s, o) {
      return Object.prototype.hasOwnProperty.call(s, o);
    }
    return r(t, "id") || (t.id = this.id), t;
  }
  get content() {
    return this.data.content || "";
  }
  get components() {
    return (this.data.components || []).map((t) => new S(t));
  }
  get head() {
    return new S(this.data.head || { tagName: "head" });
  }
  get docEl() {
    return this.data.docEl;
  }
  get classes() {
    return (this.data.classes || []).map((e) => typeof e == "string" ? e : e.name);
  }
}
class _ {
  constructor(t) {
    this.data = t;
  }
  get component() {
    return this.data.component ? new S(this.data.component) : null;
  }
}
class V {
  constructor(t) {
    this.data = t;
  }
  get id() {
    return this.data.id;
  }
  get frames() {
    return (this.data.frames || []).map((t) => new _(t));
  }
}
function E(n) {
  const t = /(-?\d*\.?\d+)\w{0,}/.exec(n);
  return t ? parseFloat(t[1]) : Number.MAX_VALUE;
}
class q {
  constructor(t) {
    this.rules = t;
  }
  getAll() {
    return this.rules;
  }
  getRulesByGroup(t) {
    return this.rules.filter((e) => e.group === t);
  }
  getAtRule(t) {
    const { atRuleType: e, mediaText: r } = t, s = e ? `@${e}` : r ? "@media" : "";
    return s + (r && s ? ` ${r}` : "");
  }
  selectorsToString(t, e = {}) {
    const r = [], { state: s, selectorsAdd: o, selectors: i = [] } = t, c = i.map((u) => this.getFromSelectorName(u)).join(""), a = s && !e.skipState ? `:${s}` : "";
    return c && r.push(`${c}${a}`), o && !e.skipAdd && r.push(o), r.join(", ");
  }
  getFromSelectorName(t = "") {
    return `${t.startsWith("#") ? "" : "."}${t}`;
  }
  styleToString(t = {}) {
    const e = [], { style: r = {}, important: s } = t;
    for (const o in r) {
      const i = Array.isArray(s) ? s.indexOf(o) >= 0 : s;
      if (o.substring(0, 2) === "__") continue;
      const a = r[o];
      (Array.isArray(a) ? a : [a]).forEach((f) => {
        const d = `${f}${i ? " !important" : ""}`;
        d && e.push(`${o}:${d};`);
      });
    }
    return e.join("");
  }
  getDeclaration(t) {
    const { singleAtRule: e } = t, r = this.selectorsToString(t), s = this.styleToString(t);
    let o = "";
    return (r || e) && s && (o = e ? s : `${r}{${s}}`), o;
  }
  buildFromRule(t) {
    let e = "";
    const r = this.selectorsToString(t), { selectorsAdd: s, singleAtRule: o } = t;
    if (r || s || o) {
      const i = this.getDeclaration(t);
      i && (e += i);
    }
    return e;
  }
  sortMediaObject(t = {}) {
    const e = [];
    for (const r in t) {
      const s = t[r];
      e.push({ key: r, value: s });
    }
    return e.sort((r, s) => {
      const o = [r.key, s.key].every((a) => a.indexOf("min-width") !== -1), i = o ? r.key : s.key, c = o ? s.key : r.key;
      return E(i) - E(c);
    });
  }
  getCssAsString() {
    if (!this.rules || !this.rules.length) return "";
    const { rules: t } = this, e = {}, r = [];
    return t.forEach((s) => {
      const o = this.getAtRule(s);
      if (o) {
        const i = e[o];
        i ? i.push(s) : e[o] = [s];
        return;
      }
      r.push(this.buildFromRule(s));
    }), this.sortMediaObject(e).forEach((s) => {
      let o = "";
      const i = s.key;
      s.value.forEach((a) => {
        const u = this.buildFromRule(a);
        a.singleAtRule ? r.push(`${i}{${u}}`) : o += u;
      }), o && r.push(`${i}{${o}}`);
    }), r.join(`
`);
  }
}
class J {
  constructor(t) {
    this.list = t;
  }
  getAll() {
    return this.list;
  }
}
class K {
  constructor(t) {
    this.pages = t.map((e) => new V(e));
  }
  getAll() {
    return this.pages;
  }
}
class G {
  constructor(t) {
    this.Css = new q(t.styles || []), this.Pages = new K(t.pages || []), this.DataSources = new J(t.dataSources || []);
  }
}
function O(n, t) {
  if (n.id === t) return n;
  for (const e of n.components) {
    const r = O(e, t);
    if (r) return r;
  }
  return null;
}
const Y = function(n) {
  var d;
  const { projectData: t, config: e = {}, pageId: r, componentId: s } = n, o = new G(t), i = o.Css.getCssAsString(), c = o.Pages.getAll();
  if (!c.length)
    return /* @__PURE__ */ l(k, { ...n, errorType: m.NoPagesFound });
  const a = r ? c.find((h) => h.id === r) : c[0];
  if (!a)
    return /* @__PURE__ */ l(k, { ...n, errorType: m.PageNotFound });
  const { frames: u } = a;
  if (!u.length)
    return /* @__PURE__ */ l(k, { ...n, errorType: m.NoFramesFound });
  const f = (d = u[0]) == null ? void 0 : d.component;
  if (!f)
    return /* @__PURE__ */ l(k, { ...n, errorType: m.MissingRootComponent });
  if (s) {
    const h = O(f, s);
    if (!h)
      return /* @__PURE__ */ l(k, { ...n, errorType: m.ComponentNotFound });
    if (h) {
      const g = e.rootComponent || v;
      return /* @__PURE__ */ C(g, { children: [
        /* @__PURE__ */ l("style", { children: `${i}` }),
        /* @__PURE__ */ l(R, { component: h, config: e })
      ] });
    }
    return null;
  }
  return /* @__PURE__ */ l(U, { config: e, root: f, css: i });
};
export {
  Y as RenderProject
};
