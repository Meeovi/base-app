import * as _elastic_elasticsearch_lib_api_types from '@elastic/elasticsearch/lib/api/types';
import { SearchHit, SearchResponseBody, QueryDslQueryContainer, KnnQuery, MappingRuntimeFieldType, SearchRequest as SearchRequest$1, AggregationsAggregationContainer } from '@elastic/elasticsearch/lib/api/types';
export { SearchRequest as ElasticsearchSearchRequest } from '@elastic/elasticsearch/lib/api/types';
import { MultipleQueriesQuery as MultipleQueriesQuery$1 } from '@algolia/client-search';
export { MultipleQueriesQuery as AlgoliaMultipleQueriesQuery } from '@algolia/client-search';

type ElasticsearchHitDocument = Record<string, unknown>;
type ElasticsearchHit = SearchHit<ElasticsearchHitDocument>;
type ElasticsearchResponseBody = SearchResponseBody<ElasticsearchHitDocument>;
type ElasticsearchQuery = QueryDslQueryContainer;
type ElasticsearchAggregation = AggregationsAggregationContainer;
type KnnSearchQuery = KnnQuery;
type MultipleQueriesQuery = MultipleQueriesQuery$1;
type FacetFieldConfig = {
    attribute: string;
    field: string;
    type: 'numeric' | 'string' | 'date';
    nestedPath?: string;
};
type FacetStringResponse = Record<string, number>;
type CustomFacetConfig = {
    field: string;
    attribute: string;
    type: 'numeric' | 'string' | 'date';
    nestedPath?: string;
    /**
     * @description Allows you to customise the facet query that is sent to Elasticsearch. This is useful for custom facets that don't fit the standard terms aggregation.
     */
    facetQuery: (field: string, size: number, search: string) => ElasticsearchAggregation;
    /**
     * @description Allows you to customise the filter query that is sent to Elasticsearch. This is useful for custom filters that don't fit the standard term query.
     */
    filterQuery: (field: string, value: string) => ElasticsearchQuery;
    /**
     * @description Allows you to handle the facet response into a key value record of facet values and counts.
     */
    facetResponse: (aggregation: any) => FacetStringResponse;
};
type FilterAttribute = {
    attribute: string;
    field: string;
    type: 'numeric' | 'string' | 'date';
    /**
     * @description Supports documents with nested fields. This is the path to the nested field.
     */
    nestedPath?: string;
    /**
     * @description Allows you to customise the filter query that is sent to Elasticsearch. This is useful for custom filters that don't fit the standard term query.
     */
    filterQuery?: (field: string, value: string) => ElasticsearchQuery;
};
interface BasicAuth {
    username: string;
    password: string;
}
interface ConfigConnection {
    /**
     * @description The Elasticsearch host
     * @example http://localhost:9200
     */
    host?: string;
    /**
     * @description The Elasticsearch API key. This is optional and only required if you have API key authentication enabled.
     * @example 1234567890
     */
    apiKey?: string;
    /**
     * @description Headers to be sent with the Elasticsearch request.
     * @example { 'X-My-Header': 'My-Value' }
     */
    headers?: Record<string, string>;
    /**
     * @description The Elasticsearch cloud id. This is optional and can be used to connect to Elasticsearch cloud. An alternative to host.
     */
    cloud_id?: string;
    /**
     * @description The Elasticsearch account. This is optional and only required if you have basic authentication enabled.
     * @example username: elastic
     * @example password: changeme
     */
    auth?: BasicAuth;
    withCredentials?: boolean;
}
interface SearchAttributeConfig {
    field: string;
    weight?: number;
}
type FacetAttribute = string | FacetFieldConfig | CustomFacetConfig;
type SearchAttribute = string | SearchAttributeConfig;
type SortingOption = {
    /** The field to sort by */
    field: string;
    /** Sort order: ascending or descending */
    order: 'asc' | 'desc';
    /** Path to nested field (e.g., 'marketplace' for marketplace.price) */
    nestedPath?: string;
    /**
     * Mode for handling array values in sorting. Useful when sorting by fields that contain arrays.
     * - 'min': Use the minimum value from the array
     * - 'max': Use the maximum value from the array
     * - 'sum': Use the sum of all values in the array
     * - 'avg': Use the average of all values in the array
     * - 'median': Use the median value from the array
     */
    mode?: 'min' | 'max' | 'sum' | 'avg' | 'median';
};
interface SearchSettingsConfig {
    /**
     * @description fields that will be searched when a user enters a query
     */
    search_attributes: SearchAttribute[];
    /**
     * @description fields that will be used to as facets
     */
    facet_attributes?: FacetAttribute[];
    /**
     * @description fields that will be used to as filters
     */
    filter_attributes?: FilterAttribute[];
    /**
     * @description fields that will be returned in the search results
     * @example ['name', 'price']
     **/
    result_attributes: string[];
    /**
     * @description fields that can be used to highlight search terms in the search results
     * @example ['name']
     **/
    highlight_attributes?: string[];
    /**
     * @description fields that can be used to generate a snippet of text matches from the search results
     * @example ['description']
     **/
    snippet_attributes?: string[];
    /**
     * @description Rules that can customise search results order.
     */
    query_rules?: QueryRule[];
    /**
     * @description Sorting options for the search. This is optional and will default to sorting by _score if not provided.
     * @example { 'price': { field: 'price', order: 'asc' } }
     * @example { 'price': [{ field: 'price', order: 'asc' }, { field: 'name', order: 'asc' }] }
     * @example { '_price_desc': { field: 'price', order: 'desc', nestedPath: 'marketplace' } }
     * @example { '_price_min': { field: 'price', order: 'asc', mode: 'min' } }
     * @example { '_price_max_nested': { field: 'price', order: 'desc', nestedPath: 'marketplace', mode: 'max' } }
     */
    sorting?: Record<string, SortingOption | SortingOption[]>;
    /**
     * @description The fuzziness of the text search query. Defaults to AUTO:4,8
     */
    fuzziness?: string;
    /**
     * @description The attribute that will be used for geo search. This is required if you want to use geo search. Must be am Elasticsearch geo_point type field.
     */
    geo_attribute?: string;
    /**
     * @description Runtime mappings that will be applied to the search. This allows you to dynamically add fields to the search results that aren't in the index.
     */
    runtime_mappings?: Record<string, RuntimeMapping>;
}
interface QueryStringRuleCondition {
    context: 'query';
    match_type: 'prefix' | 'contains' | 'exact';
    value: string;
}
interface RuntimeMapping {
    type: MappingRuntimeFieldType;
    script: {
        source: string;
    };
}
interface ContextRuleCondition {
    context: 'context';
    value: string[];
}
interface FilterRuleCondition {
    context: 'filterPresent';
    values: {
        attribute: string;
        value: string;
    }[];
}
interface PinnedResultAction {
    action: 'PinnedResult';
    documentIds: string[];
}
interface QueryBoostAction {
    action: 'QueryBoost';
    query: string;
    weight: number;
}
interface FilterAction {
    action: 'QueryFilter';
    query: string;
}
interface QueryRewriteAction {
    action: 'QueryRewrite';
    query: string;
}
interface RenderUserDataAction {
    action: 'RenderUserData';
    userData: string;
}
interface RenderFacetsOrderAction {
    action: 'RenderFacetsOrder';
    facetAttributesOrder: string[];
}
type QueryRuleAction = PinnedResultAction | QueryBoostAction | QueryRewriteAction | RenderUserDataAction | RenderFacetsOrderAction | FilterAction;
type QueryRuleCondition = QueryStringRuleCondition | ContextRuleCondition | FilterRuleCondition;
interface QueryRule {
    id: string;
    conditions: QueryRuleCondition[][];
    actions: QueryRuleAction[];
}
interface SearchkitConfig {
    connection: ConfigConnection | Transporter;
    search_settings: SearchSettingsConfig;
}
type SearchRequest = {
    body: SearchRequest$1;
    request: MultipleQueriesQuery$1;
    indexName: string;
};
interface RequestOptions {
    /**
     * @description Allows you to override the organic query
     * @param query The original query search terms
     * @param search_attributes The search attributes configured in the search settings
     * @param config The search settings
     * @returns An Elasticsearch query object or an array of Elasticsearch query objects
     * @returns false if you want to skip the search query (useful for just KNN search)
     */
    getQuery?: (query: string, search_attributes: SearchAttribute[], config: SearchSettingsConfig) => ElasticsearchQuery | ElasticsearchQuery[] | false;
    /**
     * @description Allows you to add base filters to be applied to the search. This is useful for user / document level permissions
     * @returns An array of Elasticsearch query objects that will be wrapped in a bool filter query
     **/
    getBaseFilters?: () => ElasticsearchQuery[];
    /**
     * @description Allows you to specify the KNN query to be used for KNN search. Hits will be combined with the organic query. If you do not want to use the organic query, return false from getQuery.
     * @param query The original query search terms
     * @param search_attributes The search attributes configured in the search settings
     * @param config The search settings
     * @returns An Elasticsearch KNN Search Query
     */
    getKnnQuery?: (query: string, search_attributes: SearchAttribute[], config: SearchSettingsConfig) => KnnQuery;
    /**
     * @description Hooks are escape hatches that allow you to modify the search requests to Elasticsearch and the responses back from Elasticsearch.
     **/
    hooks?: {
        /**
         * @description Allows you to modify the search requests before they are sent to Elasticsearch
         * @param requests An array of SearchRequest objects, each containing the body (elasticsearch query) and indexName of the request
         * @returns An array of modified SearchRequest objects, each containing the body (elasticsearch query) and indexName of the request
         */
        beforeSearch?: (requests: SearchRequest[]) => Promise<SearchRequest[]>;
        /**
         * @description Allows you to modify the search responses before its transformed into an InstantSearch response
         * @param requests An array of SearchRequest objects, each containing the body (elasticsearch query) and indexName of the request
         * @param responses An array of Elasticsearch Response objects
         * @returns An array of modified Elasticsearch response objects
         */
        afterSearch?: (requests: SearchRequest[], responses: ElasticsearchResponseBody[]) => Promise<ElasticsearchResponseBody[]>;
    };
}
interface Transporter {
    config?: ConfigConnection;
    msearch: (requests: SearchRequest[]) => Promise<ElasticsearchResponseBody[]>;
}
interface AppSettings {
    debug: boolean;
}

declare class ESTransporter implements Transporter {
    config: ConfigConnection;
    private settings;
    constructor(config: ConfigConnection, settings: AppSettings);
    createElasticsearchQueryFromRequest(requests: SearchRequest[]): string;
    performNetworkRequest(requests: SearchRequest[]): Promise<Response>;
    msearch(requests: SearchRequest[]): Promise<ElasticsearchResponseBody[]>;
}

declare const TermFilter: (field: string, value: string) => {
    term: {
        [x: string]: string;
    };
};
declare const MatchFilter: (field: string, value: string) => {
    match: {
        [x: string]: string;
    };
};

declare class Searchkit {
    private config;
    private settings;
    private transporter;
    constructor(config: SearchkitConfig, settings?: AppSettings);
    private performSearch;
    handleInstantSearchRequests(instantsearchRequests: readonly MultipleQueriesQuery$1[], requestOptions?: RequestOptions): Promise<{
        results: ({
            facetHits: any;
            exhaustiveFacetsCount: boolean;
            processingTimeMS: number;
        } | {
            userData?: unknown[] | undefined;
            hits: {
                _geoloc?: {
                    lat: number;
                    lng: number;
                } | null | undefined;
                _snippetResult?: Record<string, any> | undefined;
                _highlightResult?: Record<string, any> | undefined;
                inner_hits?: Record<string, _elastic_elasticsearch_lib_api_types.SearchInnerHitsResult> | undefined;
                objectID: string;
                _index: string;
                _score: number | null | undefined;
            }[];
            index: string;
            params: string;
            renderingContent: {
                facetOrdering: {
                    facets: {
                        order: string[];
                    };
                    values: Record<string, {
                        sortRemainingBy: "count";
                    }> | undefined;
                };
            };
            hitsPerPage: number;
            processingTimeMS: number;
            nbHits: number | undefined;
            page: number;
            nbPages: number;
            query: string;
            appliedRules: string[];
            exhaustiveNbHits: boolean;
            exhaustiveFacetsCount: boolean;
            exhaustiveTypo: boolean;
            exhaustive: {
                facetsCount: boolean;
                nbHits: boolean;
                typo: boolean;
            };
        })[];
    }>;
}

export { AppSettings, BasicAuth, ConfigConnection, CustomFacetConfig, ESTransporter, ElasticsearchHit, ElasticsearchQuery, ElasticsearchResponseBody, FacetAttribute, FacetFieldConfig, FacetStringResponse, FilterAttribute, KnnSearchQuery, MatchFilter, MultipleQueriesQuery, QueryRule, QueryRuleAction, QueryRuleCondition, RequestOptions, SearchAttribute, SearchAttributeConfig, SearchRequest, SearchSettingsConfig, SearchkitConfig, SortingOption, TermFilter, Transporter, Searchkit as default };
