{"version":3,"sources":["../../../../node_modules/deepmerge/dist/cjs.js","../../src/index.ts","../../src/transformRequest.ts","../../src/filterUtils.ts","../../src/utils.ts","../../src/filters.ts","../../src/sorting.ts","../../src/highlightUtils.ts","../../src/transformResponse.ts","../../src/Transporter.ts","../../src/queryRules.ts"],"sourcesContent":["'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n","import type { MultipleQueriesQuery as AlgoliaMultipleQueriesQuery } from '@algolia/client-search'\nimport { transformRequest } from './transformRequest'\nimport transformResponse, { transformFacetValuesResponse } from './transformResponse'\nimport { SearchkitConfig, SearchRequest, RequestOptions, Transporter, AppSettings } from './types'\nimport { ESTransporter } from './Transporter'\nimport { getQueryRulesActionsFromRequest, QueryRuleActions } from './queryRules'\nimport { createElasticsearchQueryFromRequest } from './utils'\nimport { getIndexName } from './sorting'\nexport * from './types'\nexport * from './Transporter'\nexport * from './filterUtils'\n\nexport default class Searchkit {\n  private transporter: Transporter\n\n  constructor(private config: SearchkitConfig, private settings: AppSettings = { debug: false }) {\n    this.transporter =\n      'msearch' in config.connection\n        ? config.connection\n        : new ESTransporter(config.connection, settings)\n  }\n\n  private async performSearch(requests: SearchRequest[]) {\n    if (this.settings.debug) {\n      console.log('Performing search with requests:')\n      console.log('POST /_msearch')\n      console.log(createElasticsearchQueryFromRequest(requests))\n    }\n    const responses = await this.transporter.msearch(requests)\n    return responses\n  }\n\n  async handleInstantSearchRequests(\n    instantsearchRequests: readonly AlgoliaMultipleQueriesQuery[],\n    requestOptions?: RequestOptions\n  ) {\n    if (!instantsearchRequests || Array.isArray(instantsearchRequests) === false) {\n      console.log({ instantsearchRequests })\n      throw new Error(\n        'No instantsearch requests provided. Check that the data you are providing from API request is correct. Likely you are not passing the request body correctly, its still a JSON string or the API is not a POST request.'\n      )\n    }\n\n    const queryRules = this.config.search_settings.query_rules || []\n\n    const requestQueryRuleActions: QueryRuleActions[] = instantsearchRequests.map((request) => {\n      return getQueryRulesActionsFromRequest(queryRules, request, this.config.search_settings)\n    })\n\n    let esRequests: SearchRequest[] = instantsearchRequests.map((request, i) => ({\n      body: transformRequest(\n        request,\n        this.config.search_settings,\n        requestQueryRuleActions[i],\n        requestOptions\n      ),\n      request: request,\n      indexName: getIndexName(request.indexName, this.config.search_settings)\n    }))\n\n    if (requestOptions?.hooks?.beforeSearch) {\n      esRequests = await requestOptions.hooks.beforeSearch(esRequests)\n    }\n\n    let esResponses = await this.performSearch(esRequests)\n\n    if (requestOptions?.hooks?.afterSearch) {\n      esResponses = await requestOptions.hooks.afterSearch(esRequests, esResponses)\n    }\n\n    try {\n      const instantsearchResponses = esResponses.map((response, i) => {\n        // @ts-ignore\n        if (instantsearchRequests[i].params?.facetName) {\n          return transformFacetValuesResponse(response, instantsearchRequests[i])\n        }\n        return transformResponse(\n          response,\n          instantsearchRequests[i],\n          this.config.search_settings,\n          requestQueryRuleActions[i]\n        )\n      })\n\n      return {\n        results: instantsearchResponses\n      }\n    } catch (err) {\n      console.error(err)\n      throw new Error(\n        'Error transforming response. Check the afterSearch hook function is correct. Likely you are not returning the correct response object.'\n      )\n    }\n  }\n}\n","import {\n  QueryDslQueryContainer,\n  RankContainer,\n  RrfRank\n} from '@elastic/elasticsearch/lib/api/types'\nimport deepmerge from 'deepmerge'\nimport {\n  transformBaseFilters,\n  transformFacetFilters,\n  transformGeoFilters,\n  transformNumericFilters\n} from './filters'\nimport { QueryRuleActions } from './queryRules'\nimport { getSorting } from './sorting'\nimport {\n  FacetAttribute,\n  KnnSearchQuery,\n  RequestOptions,\n  SearchAttribute,\n  SearchSettingsConfig\n} from './types'\nimport { AlgoliaMultipleQueriesQuery, ElasticsearchSearchRequest } from './types'\nimport { getFacet, isNestedFacet } from './utils'\n\nexport const createRegexQuery = (queryString: string) => {\n  let query = queryString.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n  query = query\n    .split('')\n    .map((char) => {\n      if (/[a-z]/.test(char)) {\n        return `[${char}${char.toUpperCase()}]`\n      }\n      return char\n    })\n    .join('')\n  query = `${query}.*`\n  if (queryString.length > 2) {\n    query = `([a-zA-Z]+ )+?${query}`\n  }\n  return query\n}\n\nconst TermAggregation = (field: string, size: number, search: string) => {\n  const searchInclude = search && search.length > 0 ? { include: createRegexQuery(search) } : {}\n  return {\n    terms: {\n      field,\n      size,\n      ...searchInclude\n    }\n  }\n}\n\nconst getTermAggregation = (facet: FacetAttribute, size: number, search: string) => {\n  let aggEntries = {}\n  const AggregationFn =\n    typeof facet !== 'string' && 'facetQuery' in facet ? facet.facetQuery : TermAggregation\n\n  const getInnerAggs = (facetName: string, field: string): any => {\n    if (typeof facet === 'string' || facet.type === 'string') {\n      aggEntries = {\n        [facetName]: AggregationFn(field, size, search)\n      }\n    } else if (facet.type === 'numeric') {\n      aggEntries = {\n        [facetName + '$_stats']: {\n          stats: {\n            field: field\n          }\n        },\n        [facetName + '$_entries']: AggregationFn(field, size, search)\n      }\n    }\n    return aggEntries\n  }\n\n  if (typeof facet === 'string') {\n    return getInnerAggs(facet, facet)\n  } else if (isNestedFacet(facet)) {\n    return {\n      [`${facet.nestedPath}.`]: {\n        nested: {\n          path: facet.nestedPath\n        },\n        aggs: getInnerAggs(facet.attribute, `${facet.nestedPath}.${facet.field}`)\n      }\n    }\n  } else {\n    return getInnerAggs(facet.attribute, facet.field)\n  }\n}\n\nexport const getAggs = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig,\n  queryRuleActions: QueryRuleActions\n) => {\n  const { params = {}, type } = request\n  // @ts-ignore\n  const { facets, maxValuesPerFacet, facetName, facetQuery } = params\n  const maxFacetSize = maxValuesPerFacet || 10\n  const facetAttributes = config.facet_attributes || []\n\n  if (facetName) {\n    const facet = getFacet(facetAttributes, facetName)\n    if (!facet) return null\n    return getTermAggregation(facet, maxFacetSize, facetQuery)\n  } else if (Array.isArray(facets)) {\n    let facetAttibutes = config.facet_attributes || []\n\n    if (queryRuleActions.facetAttributesOrder) {\n      facetAttibutes = queryRuleActions.facetAttributesOrder\n        .map((attribute) => {\n          return getFacet(config.facet_attributes || [], attribute)\n        })\n        .filter((x): x is FacetAttribute => x !== null)\n    }\n\n    const facetAttributes: FacetAttribute[] =\n      facets[0] === '*'\n        ? facetAttibutes\n        : facets\n            .map((facetAttribute) => {\n              return getFacet(config.facet_attributes || [], facetAttribute)\n            })\n            .filter((x): x is FacetAttribute => x !== null)\n\n    return (\n      facetAttributes.reduce((sum, facet) => {\n        return deepmerge(sum, getTermAggregation(facet, maxFacetSize, ''))\n      }, {}) || {}\n    )\n  } else if (typeof facets === 'string') {\n    const field = getFacet(config.facet_attributes || [], facets)\n    if (!field) return {}\n    return getTermAggregation(field, maxFacetSize, '')\n  }\n}\n\nfunction queryRulesWrapper(organicQuery: any, queryRuleActions: QueryRuleActions) {\n  if (queryRuleActions.touched) {\n    return {\n      function_score: {\n        query: {\n          pinned: {\n            ids: queryRuleActions.pinnedDocs,\n            organic: organicQuery\n          }\n        },\n        functions: queryRuleActions.boostFunctions\n      }\n    }\n  }\n  return organicQuery\n}\n\nexport function RelevanceQueryMatch(query: string, search_attributes: SearchAttribute[], fuzziness: string = 'AUTO:4,8') {\n  const getFieldsMap = (boostMultiplier: number) => {\n    return search_attributes.map((attribute) => {\n      return typeof attribute === 'string'\n        ? attribute\n        : `${attribute.field}^${(attribute.weight || 1) * boostMultiplier}`\n    })\n  }\n\n  return {\n    bool: {\n      should: [\n        {\n          bool: {\n            should: [\n              {\n                multi_match: {\n                  query: query,\n                  fields: getFieldsMap(1),\n                  fuzziness: fuzziness\n                }\n              },\n              {\n                multi_match: {\n                  query: query,\n                  fields: getFieldsMap(0.5),\n                  type: 'bool_prefix'\n                }\n              }\n            ]\n          }\n        },\n        {\n          multi_match: {\n            query: query,\n            type: 'phrase',\n            fields: getFieldsMap(2)\n          }\n        }\n      ]\n    }\n  }\n}\n\nconst getQuery = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig,\n  queryRuleActions: QueryRuleActions,\n  requestOptions?: RequestOptions\n): { query?: QueryDslQueryContainer; knn?: KnnSearchQuery; rank?: RankContainer } => {\n  const query = queryRuleActions.query\n\n  const searchAttributes = config.search_attributes\n  const fuzziness = config.fuzziness ?? 'AUTO:4,8'\n\n  const filters = [\n    ...transformFacetFilters(request, config),\n    ...transformNumericFilters(request, config),\n    ...transformBaseFilters(request, config),\n    ...transformGeoFilters(request, config),\n    ...(requestOptions?.getBaseFilters?.() || []),\n    ...queryRuleActions.baseFilters\n  ]\n\n  let organicQuery =\n    typeof query === 'string' && query !== ''\n      ? requestOptions?.getQuery\n        ? requestOptions.getQuery(query, searchAttributes, config)\n        : RelevanceQueryMatch(query, searchAttributes, fuzziness)\n      : {\n          match_all: {}\n        }\n\n  const hasKnn = typeof requestOptions?.getKnnQuery === 'function'\n  const hasNoQuery = requestOptions?.getQuery?.(query, searchAttributes, config) === false\n\n  if (hasNoQuery || (hasKnn && query === '')) {\n    organicQuery = {\n      match_all: {}\n    }\n  }\n\n  const queryDsl = {\n    bool: {\n      filter: filters,\n      must: queryRuleActions.touched\n        ? queryRulesWrapper(organicQuery, queryRuleActions)\n        : organicQuery\n    }\n  }\n\n  let knnQueryDsl: KnnSearchQuery | null = null\n\n  if (hasKnn && query !== '') {\n    knnQueryDsl = {\n      filter: filters,\n      ...(requestOptions?.getKnnQuery?.(query, searchAttributes, config) || {})\n    } as KnnSearchQuery\n  }\n\n  if (query !== '' && hasNoQuery && hasKnn && knnQueryDsl) {\n    return {\n      knn: knnQueryDsl\n    }\n  }\n\n  const size = getHitsPerPage(request)\n\n  return {\n    query: queryDsl,\n    knn: knnQueryDsl ? knnQueryDsl : undefined,\n    // in hybrid mode (knn + keyword query), is displaying results and query is not empty\n    rank:\n      hasKnn && !hasNoQuery && size > 0 && query !== '' ? { rrf: { window_size: size } } : undefined\n  }\n}\n\nconst getHitsPerPage = (request: AlgoliaMultipleQueriesQuery) => {\n  const { params = {} } = request\n  return params.hitsPerPage == null ? 20 : params.hitsPerPage\n}\n\nconst getResultsSize = (request: AlgoliaMultipleQueriesQuery, config: SearchSettingsConfig) => {\n  const { params = {} } = request\n  const hitsPerPage = getHitsPerPage(request)\n\n  return {\n    size: hitsPerPage,\n    from: (params.page || 0) * hitsPerPage\n  }\n}\n\nexport const getHitFields = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n) => {\n  const { params = {} } = request\n  const { attributesToRetrieve } = params\n  // ignoring attributesToRetrieve for now\n\n  const sourceFields = new Set([\n    ...(config.result_attributes || []),\n    ...(config.highlight_attributes || []),\n    ...(config.geo_attribute ? [config.geo_attribute] : [])\n  ])\n\n  const runtimeFields = Object.keys(config.runtime_mappings || {})\n  const fields = runtimeFields.reduce<string[]>((sum, field) => {\n    if (config.result_attributes?.includes(field)) {\n      return [field, ...sum]\n    }\n    return sum\n  }, [])\n\n  return {\n    _source: {\n      includes: Array.from(sourceFields)\n    },\n    ...(fields.length > 0 ? { fields } : {})\n  }\n}\n\nexport const getSnippetFieldLength = (attribute: string) => {\n  const defaultMatch = {\n    attribute,\n    length: 100\n  }\n  if (!attribute.includes(':')) {\n    return defaultMatch\n  }\n  const match = attribute.match(/(.+)\\:(\\d+)/)\n  if (!match) return defaultMatch\n  return {\n    attribute: match[1],\n    length: parseInt(match[2])\n  }\n}\n\nexport const getHighlightFields = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n) => {\n  const { params = {} } = request\n  const { attributesToHighlight } = params\n  // ignoring attributesToHighlight for now\n\n  const highlightFields =\n    config.highlight_attributes?.reduce(\n      (sum, field) => ({\n        ...sum,\n        [field]: {\n          number_of_fragments: 0\n        }\n      }),\n      {}\n    ) || {}\n\n  const snippetFields =\n    config.snippet_attributes?.reduce(\n      (sum, attribute) => ({\n        ...sum,\n        [getSnippetFieldLength(attribute).attribute]: {\n          number_of_fragments: 5,\n          fragment_size: getSnippetFieldLength(attribute).length\n        }\n      }),\n      {}\n    ) || {}\n\n  if (Object.keys(highlightFields).length === 0 && Object.keys(snippetFields).length === 0) {\n    return {}\n  }\n\n  return {\n    highlight: {\n      pre_tags: ['<em>'],\n      post_tags: ['</em>'],\n      fields: {\n        ...highlightFields,\n        ...snippetFields\n      }\n    }\n  }\n}\n\nconst getRuntimeMappings = (request: AlgoliaMultipleQueriesQuery, config: SearchSettingsConfig) => {\n  if (!config.runtime_mappings) {\n    return {}\n  }\n\n  return {\n    runtime_mappings: config.runtime_mappings\n  }\n}\n\nexport function transformRequest(\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig,\n  queryRuleActions: QueryRuleActions,\n  requestOptions?: RequestOptions\n): ElasticsearchSearchRequest {\n  const body: ElasticsearchSearchRequest = {\n    aggs: getAggs(request, config, queryRuleActions),\n    ...getQuery(request, config, queryRuleActions, requestOptions),\n    ...getResultsSize(request, config),\n    ...getHitFields(request, config),\n    ...getHighlightFields(request, config),\n    ...getSorting(request, config),\n    ...getRuntimeMappings(request, config)\n  }\n\n  return body\n}\n","export const TermFilter = (field: string, value: string) => {\n  return { term: { [field]: value } }\n}\n\nexport const MatchFilter = (field: string, value: string) => {\n  return { match: { [field]: value } }\n}\n","import { CustomFacetConfig, FacetAttribute, FacetFieldConfig, SearchRequest } from './types'\n\nexport const createRegexQuery = (queryString: string) => {\n  let query = queryString.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n  query = query\n    .split('')\n    .map((char) => {\n      if (/[a-z]/.test(char)) {\n        return `[${char}${char.toUpperCase()}]`\n      }\n      return char\n    })\n    .join('')\n  query = `${query}.*`\n  if (queryString.length > 2) {\n    query = `([a-zA-Z]+ )+?${query}`\n  }\n  return query\n}\n\nexport const getFacet = (\n  facet_attributes: FacetAttribute[],\n  attributeName: string\n): FacetAttribute | null => {\n  const f = facet_attributes.find((a) => {\n    if (typeof a === 'string') {\n      return a === attributeName\n    }\n    return a.attribute === attributeName\n  })\n  return f || null\n}\n\nexport const isNestedFacet = (facet: FacetAttribute): boolean => {\n  return typeof facet !== 'string' && !!facet.nestedPath\n}\n\nexport const getFacetField = (\n  facet_attributes: FacetAttribute[],\n  attribute: FacetAttribute\n): string => {\n  const attributeKey = typeof attribute === 'string' ? attribute : attribute.attribute\n\n  if (facet_attributes.includes(attributeKey)) {\n    return attributeKey\n  }\n  return (\n    facet_attributes\n      // @ts-ignore: object is possibly null\n      .find((a) => a.attribute === attributeKey)?.field || attributeKey\n  )\n}\n\nexport const getFacetByAttribute = (\n  facet_attributes: FacetAttribute[],\n  attribute: FacetAttribute\n): string => {\n  const attributeKey = getFacetAttribute(attribute)\n\n  if (facet_attributes.includes(attributeKey)) {\n    return attributeKey\n  }\n  return (\n    facet_attributes\n      // @ts-ignore: object is possibly null\n      .find((a) => a.attribute === attributeKey)?.attribute || attributeKey\n  )\n}\n\nexport const getFacetAttribute = (facetAttribute: FacetAttribute): string => {\n  return typeof facetAttribute === 'string' ? facetAttribute : facetAttribute.attribute\n}\n\nexport const getFacetFieldType = (\n  facet_attributes: FacetAttribute[],\n  attribute: FacetAttribute\n): FacetFieldConfig['type'] => {\n  const attributeKey = typeof attribute === 'string' ? attribute : attribute.attribute\n\n  if (facet_attributes.includes(attributeKey)) {\n    return 'string'\n  }\n  return (\n    facet_attributes\n      // @ts-ignore: object is possibly null\n      .find((a) => a?.attribute === attributeKey)?.type || 'string'\n  )\n}\n\nexport const getFacetFieldConfig = (\n  facet_attributes: FacetAttribute[],\n  attribute: FacetAttribute\n): FacetFieldConfig | CustomFacetConfig | undefined => {\n  return facet_attributes.find((a) => {\n    if (typeof a === 'string') {\n      return false\n    }\n    return a.attribute === attribute\n  }) as FacetFieldConfig | CustomFacetConfig | undefined\n}\n\nexport const createElasticsearchQueryFromRequest = (requests: SearchRequest[]) => {\n  return requests\n    .reduce<string[]>(\n      (sum, request) => [\n        ...sum,\n        JSON.stringify({ index: request.indexName }),\n        '\\n',\n        JSON.stringify(request.body),\n        '\\n'\n      ],\n      []\n    )\n    .join('')\n}\n","import { MatchFilter, TermFilter } from './filterUtils'\nimport type {\n  AlgoliaMultipleQueriesQuery,\n  FacetAttribute,\n  SearchSettingsConfig,\n  ElasticsearchQuery,\n  FilterAttribute,\n  FacetFieldConfig\n} from './types'\nimport { getFacet, getFacetAttribute, isNestedFacet } from './utils'\n\nexport const transformNumericFilters = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n): ElasticsearchQuery[] => {\n  const { params = {} } = request\n  const { numericFilters } = params\n\n  if (!Array.isArray(numericFilters)) {\n    return []\n  }\n\n  return numericFilters.reduce((sum, filter: string) => {\n    let match,\n      field,\n      operator,\n      value,\n      maxValue = ''\n    let groups = filter.match(\n      /([\\w\\.\\_\\-]+)\\s*(\\=|\\!\\=|\\>|\\>\\=|\\<|\\<\\=)\\s*(-?(?:\\d+(?:\\.\\d*)?|\\.\\d+))/\n    )\n\n    if (groups) {\n      ;[match, field, operator, value] = groups\n    } else {\n      // Alternative syntax: 'attribute:lower_value TO higher_value'\n      groups = filter.match(\n        /([\\w\\.\\_\\-]+):\\s*(-?(?:\\d+(?:\\.\\d*)?|\\.\\d+))\\s*([Tt][Oo])\\s*(-?(?:\\d+(?:\\.\\d*)?|\\.\\d+))/\n      )\n\n      if (!groups) {\n        throw new Error(\n          `Numeric filter \"${filter}\" could not be parsed. It should either be in the format \"attributeName operator operand\" or \"attributeName: lowerBound TO upperBound\"`\n        )\n      }\n\n      ;[match, field, value, operator, maxValue] = groups\n    }\n\n    const facetFilterMap = getFacetFilterMap(\n      config.facet_attributes || [],\n      config.filter_attributes || []\n    )\n    const facetFilterConfig = facetFilterMap[field]\n\n    const getFilter = (field: string, operator: string, value: string) => {\n      if (operator === '=') {\n        return {\n          term: {\n            [field]: value\n          }\n        }\n      } else if (operator === '!=') {\n        return {\n          bool: {\n            must_not: {\n              term: {\n                [field]: value\n              }\n            }\n          }\n        }\n      } else if (operator === '>') {\n        return {\n          range: {\n            [field]: {\n              gt: value\n            }\n          }\n        }\n      } else if (operator === '>=') {\n        return {\n          range: {\n            [field]: {\n              gte: value\n            }\n          }\n        }\n      } else if (operator === '<') {\n        return {\n          range: {\n            [field]: {\n              lt: value\n            }\n          }\n        }\n      } else if (operator === '<=') {\n        return {\n          range: {\n            [field]: {\n              lte: value\n            }\n          }\n        }\n      } else if (operator.toUpperCase() === 'TO') {\n        return {\n          range: {\n            [field]: {\n              gte: value,\n              lte: maxValue\n            }\n          }\n        }\n      }\n    }\n\n    const esFilter = []\n\n    if (facetFilterConfig.nestedPath) {\n      const nestedPathPresent = sum.find((filter: any) => {\n        return filter.nested.path === facetFilterConfig.nestedPath\n      })\n\n      if (nestedPathPresent) {\n        nestedPathPresent.nested.query.bool.filter.push(\n          getFilter(facetFilterConfig.nestedPath + '.' + facetFilterConfig.field, operator, value)\n        )\n      } else {\n        esFilter.push({\n          nested: {\n            path: facetFilterConfig.nestedPath,\n            inner_hits: {},\n            query: {\n              bool: {\n                filter: [\n                  getFilter(\n                    facetFilterConfig.nestedPath + '.' + facetFilterConfig.field,\n                    operator,\n                    value\n                  )\n                ]\n              }\n            }\n          }\n        })\n      }\n    } else {\n      esFilter.push(getFilter(facetFilterConfig.field, operator, value))\n    }\n\n    return [...sum, ...esFilter]\n  }, [])\n}\n\nconst getFacetFilterMap = (facets: FacetAttribute[], filters: FilterAttribute[]) => {\n  return [...filters, ...facets].reduce<Record<string, FacetFieldConfig | FilterAttribute>>(\n    (sum, filter) => {\n      let f: FacetFieldConfig | FilterAttribute =\n        typeof filter === 'string' ? { attribute: filter, field: filter, type: 'string' } : filter\n\n      return {\n        ...sum,\n        [f.attribute]: f\n      }\n    },\n    {}\n  )\n}\n\nexport const transformFacetFilters = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n): ElasticsearchQuery[] => {\n  const { params = {} } = request\n  const { facetFilters } = params\n\n  if (!Array.isArray(facetFilters)) {\n    return []\n  }\n\n  const facetFilterMap = getFacetFilterMap(\n    config.facet_attributes || [],\n    config.filter_attributes || []\n  )\n\n  return facetFilters.reduce((sum, filter) => {\n    if (Array.isArray(filter)) {\n      return [\n        ...sum,\n        {\n          bool: {\n            should: filter.reduce((sum, filter) => {\n              const [facet, value] = filter.split(/:(.*)/)\n              const facetFilterConfig = facetFilterMap[facet]\n              if (!facetFilterConfig)\n                throw new Error(\n                  `Facet \"${facet}\" not found in configuration. Add configuration to either facet_attributes or filter_attributes.`\n                )\n              const field = facetFilterConfig.field\n              const filterClauseFn =\n                'filterQuery' in facetFilterConfig && facetFilterConfig.filterQuery\n                  ? facetFilterConfig.filterQuery\n                  : TermFilter\n\n              if (isNestedFacet(facetFilterConfig)) {\n                // detect if there is a nested filter in sum\n                // if one doesn't exist, add one\n                // if one does exist, add to it\n                const nestedFilter = sum.find((filter: any) => {\n                  return filter.nested && filter.nested.path === facetFilterConfig.nestedPath\n                })\n\n                if (nestedFilter) {\n                  nestedFilter.nested.query.bool.should.push(\n                    filterClauseFn(\n                      `${facetFilterConfig.nestedPath}.${facetFilterConfig.field}`,\n                      value\n                    )\n                  )\n                  return sum\n                } else {\n                  return [\n                    ...sum,\n                    {\n                      nested: {\n                        inner_hits: {},\n                        path: facetFilterConfig.nestedPath,\n                        query: {\n                          bool: {\n                            should: [\n                              filterClauseFn(\n                                `${facetFilterConfig.nestedPath}.${facetFilterConfig.field}`,\n                                value\n                              )\n                            ]\n                          }\n                        }\n                      }\n                    }\n                  ]\n                }\n              }\n              return [...sum, filterClauseFn(field, value)]\n            }, [])\n          }\n        }\n      ]\n    } else if (typeof filter === 'string') {\n      const [facet, value] = filter.split(/:(.*)/)\n\n      const facetFilterConfig = facetFilterMap[facet]\n      if (!facetFilterConfig)\n        throw new Error(\n          `Facet \"${facet}\" not found in configuration. Add configuration to either facet_attributes or filter_attributes.`\n        )\n\n      const filterClauseFn =\n        'filterQuery' in facetFilterConfig && facetFilterConfig.filterQuery\n          ? facetFilterConfig.filterQuery\n          : TermFilter\n\n      if (isNestedFacet(facetFilterConfig) && facetFilterConfig.nestedPath) {\n        // detect if there is a nested filter in sum\n        // if one doesn't exist, add one\n        // if one does exist, add to it\n        const nestedFilter = sum.find((filter: any) => {\n          return filter.nested && filter.nested.path === facetFilterConfig.nestedPath + '.'\n        })\n\n        if (nestedFilter) {\n          nestedFilter.nested.query.bool.should.push(\n            filterClauseFn(`${facetFilterConfig.nestedPath}.${facetFilterConfig.field}`, value)\n          )\n          return sum\n        } else {\n          return [\n            ...sum,\n            {\n              nested: {\n                inner_hits: {},\n                path: facetFilterConfig.nestedPath,\n                query: {\n                  bool: {\n                    should: [\n                      filterClauseFn(\n                        `${facetFilterConfig.nestedPath}.${facetFilterConfig.field}`,\n                        value\n                      )\n                    ]\n                  }\n                }\n              }\n            }\n          ]\n        }\n      }\n      return [...sum, filterClauseFn(facetFilterConfig.field, value)]\n    }\n  }, [])\n}\n\nexport const transformQueryString = (\n  facets: FacetAttribute[] = [],\n  filters: FilterAttribute[] = [],\n  queryString: string\n) => {\n  const regex = /([\\w\\.\\-]+)\\:/gi\n  const filterMap = getFacetFilterMap(facets, filters)\n  return queryString.replace(regex, (match: string, word: string) => {\n    if (!filterMap[word]) {\n      throw new Error(\n        `Attribute \"${word}\" is not defined as an attribute in the facet or filter search settings`\n      )\n    }\n\n    if (!!filterMap[word].nestedPath) {\n      throw new Error(\n        `Attribute \"${word}\" is a nested field and cannot be used as a filter. Nested fields are supported in facetFilers or numericFilters.`\n      )\n    }\n\n    return filterMap[word].field + ':'\n  })\n}\n\nexport const transformBaseFilters = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n) => {\n  const { params = {} } = request\n  const { filters } = params\n\n  if (!filters || filters === '') {\n    return []\n  }\n\n  const queryString = transformQueryString(\n    config.facet_attributes,\n    config.filter_attributes,\n    filters\n  )\n\n  return [\n    {\n      query_string: {\n        query: queryString\n      }\n    }\n  ]\n}\n\nexport const transformGeoFilters = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n) => {\n  if (!config.geo_attribute) {\n    return []\n  }\n  const { params = {} } = request\n  const { aroundLatLng, aroundRadius, insideBoundingBox } = params\n\n  if (insideBoundingBox) {\n    return [insideBoundingBoxFilter(insideBoundingBox, config.geo_attribute)]\n  }\n\n  if (aroundLatLng) {\n    const geoPoint = aroundLatLng.split(',')\n\n    return [\n      {\n        geo_distance: {\n          distance: aroundRadius || '1000m',\n          [config.geo_attribute]: {\n            lat: geoPoint[0],\n            lon: geoPoint[1]\n          }\n        }\n      }\n    ]\n  }\n\n  return []\n}\n\nfunction insideBoundingBoxFilter(\n  insideBoundingBox: string | readonly (readonly number[])[],\n  field: string\n) {\n  const geoBoundingboxFilter = (top: number, left: number, bottom: number, right: number) => {\n    return {\n      geo_bounding_box: {\n        [field]: {\n          top_right: {\n            lat: top,\n            lon: left\n          },\n          bottom_left: {\n            lat: bottom,\n            lon: right\n          }\n        }\n      }\n    }\n  }\n\n  if (typeof insideBoundingBox === 'string') {\n    const [top, left, bottom, right] = insideBoundingBox.split(',')\n    return geoBoundingboxFilter(\n      parseFloat(top),\n      parseFloat(left),\n      parseFloat(bottom),\n      parseFloat(right)\n    )\n  } else if (Array.isArray(insideBoundingBox)) {\n    const geoBoundingboxes = insideBoundingBox.map((boundingBox) => {\n      const [top, left, bottom, right] = boundingBox\n      return geoBoundingboxFilter(\n        parseFloat(top),\n        parseFloat(left),\n        parseFloat(bottom),\n        parseFloat(right)\n      )\n    })\n\n    return {\n      bool: {\n        should: geoBoundingboxes\n      }\n    }\n  }\n}\n","import { SearchSettingsConfig } from './types'\nimport { AlgoliaMultipleQueriesQuery } from './types'\n\nexport function getSorting(request: AlgoliaMultipleQueriesQuery, config: SearchSettingsConfig) {\n  if (config.sorting && Object.keys(config.sorting).length > 0) {\n    const selectedSorting = Object.keys(config.sorting).find((key) => {\n      if (request.indexName.endsWith(key)) {\n        return true\n      }\n    })\n\n    if (!selectedSorting && !config.sorting.default) return {}\n\n    const sortOption = selectedSorting ? config.sorting[selectedSorting] : config.sorting.default\n\n    const buildSortField = (sorting: any) => {\n      const fieldPath = sorting.nestedPath\n        ? `${sorting.nestedPath}.${sorting.field}`\n        : sorting.field\n\n      if (sorting.nestedPath) {\n        const sortConfig: any = {\n          order: sorting.order,\n          nested: {\n            path: sorting.nestedPath\n          }\n        }\n        \n        // Add mode if specified\n        if (sorting.mode) {\n          sortConfig.mode = sorting.mode\n        }\n        \n        return {\n          [fieldPath]: sortConfig\n        }\n      }\n\n      const sortConfig: any = sorting.order\n      \n      // For non-nested fields, if mode is specified, create an object instead of just the order string\n      if (sorting.mode) {\n        return {\n          [fieldPath]: {\n            order: sorting.order,\n            mode: sorting.mode\n          }\n        }\n      }\n\n      return {\n        [fieldPath]: sortConfig\n      }\n    }\n\n    return {\n      sort: Array.isArray(sortOption) ? sortOption.map(buildSortField) : buildSortField(sortOption)\n    }\n  }\n  return {}\n}\n\nexport function getIndexName(indexName: string, config: SearchSettingsConfig) {\n  if (config.sorting && Object.keys(config.sorting).length > 0) {\n    const selectedSorting = Object.keys(config.sorting).find((key) => {\n      if (indexName.endsWith(key)) {\n        return true\n      }\n    })\n\n    if (selectedSorting) {\n      return indexName.replace(selectedSorting, '')\n    }\n  }\n  return indexName\n}\n","import { getSnippetFieldLength } from './transformRequest'\nimport type { ElasticsearchHit, SearchSettingsConfig } from './types'\n\nexport function highlightTerm(value: string, query: string): string {\n  const regex = new RegExp(query, 'gi')\n  return value.replace(regex, (match) => `<em>${match}</em>`)\n}\n\nexport function isAllowableHighlightField(fieldKey: string, highlightFields: string[]) {\n  return (\n    highlightFields.findIndex((highlightField) => {\n      if (highlightField.indexOf('*') < 0) {\n        return highlightField === fieldKey\n      }\n\n      const safeHighlightField = highlightField.replace(/[.+?^$|\\{\\}\\(\\)\\[\\]\\\\]/g, '\\\\$&')\n      const regex = new RegExp(`^${safeHighlightField.replace(/\\*/g, '.*')}$`)\n      return regex.test(fieldKey)\n    }) >= 0\n  )\n}\n\nfunction transformObject(input: Record<string, string>): Record<string, any> {\n  const result: Record<string, any> = {}\n\n  for (const key in input) {\n    const keys = key.split('.')\n    let currentObj = result\n\n    for (let i = 0; i < keys.length - 1; i++) {\n      const currentKey = keys[i]\n\n      if (!currentObj[currentKey]) {\n        currentObj[currentKey] = {}\n      }\n\n      currentObj = currentObj[currentKey]\n    }\n\n    currentObj[keys[keys.length - 1]] = input[key]\n  }\n\n  return result\n}\n\n/**\n * Retrieves a nested field value from an object using a dot-notation path.\n * If any part of the path points to an array, it maps over the array to extract the values.\n * This function ensures that a property exists, even if its value is `undefined`.\n *\n * @param {object} obj - The object to retrieve the nested value from.\n * @param {string} path - The dot-notation path to the desired value (e.g., 'messages.text').\n * @returns {any} - The value at the specified path, or undefined if the path or property does not exist.\n *                  If the path involves an array, an array of values will be returned.\n */\nexport function getFieldValue(obj: any, path: string): any {\n  return path.split('.').reduce((acc, key) => {\n    if (Array.isArray(acc)) {\n      // Map over the array and extract the value\n      return acc.map(item => item[key])\n    }\n\n    // Check if the property exists before accessing it\n    return acc && Object.prototype.hasOwnProperty.call(acc, key)\n      ? acc[key]\n      : undefined\n  }, obj)\n}\n\nexport function getHighlightFields(\n  hit: ElasticsearchHit,\n  preTag: string = '<ais-highlight-0000000000>',\n  postTag: string = '<ais-highlight-0000000000/>',\n  fields: SearchSettingsConfig['snippet_attributes'] = []\n) {\n  const { _source = {}, highlight = {} } = hit\n\n  const combinedKeys = {\n    ..._source,\n    ...highlight\n  }\n\n  const highlightFields = fields.map((field) => getSnippetFieldLength(field).attribute)\n\n  const hitHighlights = Object.keys(combinedKeys).reduce<Record<string, any>>((sum, fieldKey) => {\n    const fieldValue: any = getFieldValue(_source, fieldKey)\n    const highlightedMatch = highlight[fieldKey] || null\n\n    if (!isAllowableHighlightField(fieldKey, highlightFields)) {\n      return sum\n    }\n    // no matches, specified as a highlight and value is an array\n    if (Array.isArray(fieldValue) && !highlightedMatch) {\n      return {\n        ...sum,\n        [fieldKey]: fieldValue.map((value) => ({\n          matchLevel: 'none',\n          matchedWords: [],\n          value: value.toString()\n        }))\n      }\n      // field array and has multiple highlighted matches\n    } else if (Array.isArray(fieldValue) && highlightedMatch && Array.isArray(highlightedMatch)) {\n      return {\n        ...sum,\n        [fieldKey]: highlightedMatch.map((highlightedMatch) => {\n          const matchWords = Array.from(highlightedMatch.matchAll(/\\<em\\>(.*?)\\<\\/em\\>/g)).map(\n            (match) => match[1]\n          )\n          return {\n            fullyHighlighted: false,\n            matchLevel: 'full',\n            matchedWords: matchWords,\n            value: highlightedMatch\n              .toString()\n              .replace(/\\<em\\>/g, preTag)\n              .replace(/\\<\\/em\\>/g, postTag)\n          }\n        })\n      }\n    } else if (\n      (!Array.isArray(fieldValue) && highlightedMatch && Array.isArray(highlightedMatch)) ||\n      (!fieldValue && Array.isArray(highlightedMatch) && highlightedMatch.length > 0)\n    ) {\n      const singleMatch = highlightedMatch[0]\n\n      const matchWords = Array.from(singleMatch.matchAll(/\\<em\\>(.*?)\\<\\/em\\>/g)).map(\n        (match) => match[1]\n      )\n      const x = {\n        fullyHighlighted: false,\n        matchLevel: 'full',\n        matchedWords: matchWords,\n        value: singleMatch\n          .toString()\n          .replace(/\\<em\\>/g, preTag)\n          .replace(/\\<\\/em\\>/g, postTag)\n      }\n\n      return {\n        ...sum,\n        [fieldKey]: x\n      }\n    }\n\n    return {\n      ...sum,\n      [fieldKey]: {\n        matchLevel: 'none',\n        matchedWords: [],\n        value: fieldValue != undefined ? fieldValue.toString() : ''\n      }\n    }\n  }, {})\n\n  return transformObject(hitHighlights)\n}\n","import { FacetStringResponse, SearchSettingsConfig } from './types'\nimport { getHighlightFields, highlightTerm } from './highlightUtils'\nimport { AlgoliaMultipleQueriesQuery, ElasticsearchResponseBody } from './types'\nimport { getFacetFieldConfig, getFacetFieldType } from './utils'\nimport { QueryRuleActions } from './queryRules'\nimport type {\n  AggregationsStatsAggregate,\n  AggregationsStringTermsAggregate,\n  AggregationsStringTermsBucket,\n  AggregationsTermsAggregateBase,\n  AggregationsTermsAggregation,\n  GeoLocation\n} from '@elastic/elasticsearch/lib/api/types'\n\ntype FacetsList = Record<string, Record<string, number>>\ntype FacetsStats = Record<\n  string,\n  { min: number | null; max: number | null; avg: number | null; sum: number | null }\n>\n\nconst getHits = (\n  response: ElasticsearchResponseBody,\n  config: SearchSettingsConfig,\n  instantsearchRequest: AlgoliaMultipleQueriesQuery\n) => {\n  const { hits } = response\n  const { highlight_attributes = [], snippet_attributes = [] } = config\n\n  return hits.hits.map((hit) => ({\n    objectID: hit._id,\n    _index: hit._index,\n    _score: hit._score,\n    ...(hit._source || {}),\n    ...(hit.fields || {}), // for runtime_mapping fields\n    ...(hit.inner_hits ? { inner_hits: hit.inner_hits } : {}),\n    ...(highlight_attributes.length > 0\n      ? {\n          _highlightResult: getHighlightFields(\n            hit,\n            instantsearchRequest?.params?.highlightPreTag,\n            instantsearchRequest?.params?.highlightPostTag,\n            highlight_attributes\n          )\n        }\n      : {}),\n    ...(snippet_attributes.length > 0\n      ? {\n          _snippetResult: getHighlightFields(\n            hit,\n            instantsearchRequest?.params?.highlightPreTag,\n            instantsearchRequest?.params?.highlightPostTag,\n            config.snippet_attributes\n          )\n        }\n      : {}),\n    ...(config.geo_attribute && hit._source?.[config.geo_attribute]\n      ? { _geoloc: convertLatLng(hit._source?.[config.geo_attribute] as GeoLocation) }\n      : {})\n  }))\n}\n\nfunction convertLatLng(value: GeoLocation) {\n  if (typeof value === 'string') {\n    const [lat, lng] = value.split(',').map((v) => parseFloat(v))\n    return { lat, lng }\n  } else if (Array.isArray(value)) {\n    return { lat: value[0], lng: value[1] }\n  } else if (typeof value === 'object') {\n    if ('lat' in value && 'lon' in value) {\n      return {\n        lat: parseFloat(value.lat as unknown as string),\n        lng: parseFloat(value.lon as unknown as string)\n      }\n    }\n  }\n  return null\n}\n\nconst TermFacetResponse = (aggregation: AggregationsStringTermsAggregate) => {\n  return (aggregation.buckets as AggregationsStringTermsBucket[]).reduce<FacetStringResponse>(\n    (sum, bucket) => ({\n      ...sum,\n      [bucket.key]: bucket.doc_count\n    }),\n    {}\n  )\n}\n\nconst getFacets = (response: ElasticsearchResponseBody, config: SearchSettingsConfig) => {\n  if (!response?.aggregations) {\n    return {}\n  }\n\n  // flattening for nested facets\n  const aggregations = Object.keys(response.aggregations).reduce<Record<string, any>>(\n    (sum, key) => {\n      const value = (response.aggregations || {})[key] as any\n\n      if (key.endsWith('.')) {\n        const { doc_count, ...nestedAggregations } = value\n        return {\n          ...sum,\n          ...nestedAggregations\n        }\n      }\n\n      return {\n        ...sum,\n        [key]: value\n      }\n    },\n    {}\n  )\n\n  return Object.keys(aggregations).reduce<{\n    facets: FacetsList\n    facets_stats: FacetsStats\n  }>(\n    (sum, f) => {\n      const facet = f.split('$')[0]\n      const fieldType = getFacetFieldType(config.facet_attributes || [], facet)\n      const facetConfig = getFacetFieldConfig(config.facet_attributes || [], facet)\n      const facetResponse =\n        (facetConfig && 'facetResponse' in facetConfig && facetConfig?.facetResponse) ||\n        TermFacetResponse\n\n      if (fieldType === 'numeric') {\n        const facetValues = aggregations[facet + '$_stats'] as AggregationsStatsAggregate\n        const { buckets } = aggregations[facet + '$_entries'] as {\n          buckets: any[]\n        }\n\n        return {\n          ...sum,\n          facets: {\n            ...sum.facets,\n            [facet]: facetResponse({ buckets })\n          },\n          facets_stats: {\n            ...sum.facets_stats,\n            [facet]: {\n              min: facetValues.min,\n              avg: facetValues.avg,\n              max: facetValues.max,\n              sum: facetValues.sum\n            }\n          }\n        }\n      }\n\n      const { buckets } = aggregations[facet] as { buckets: any[] }\n\n      return {\n        ...sum,\n        facets: {\n          ...sum.facets,\n          [facet]: facetResponse({ buckets })\n        }\n      }\n    },\n    {\n      facets: {},\n      facets_stats: {}\n    }\n  )\n}\n\nconst getRenderingContent = (config: SearchSettingsConfig, queryRuleActions: QueryRuleActions) => {\n  const defaultOrder = config.facet_attributes?.map((facet) =>\n    typeof facet === 'string' ? facet : facet.attribute\n  )\n\n  return {\n    renderingContent: {\n      facetOrdering: {\n        facets: {\n          order: queryRuleActions.facetAttributesOrder || defaultOrder || []\n        },\n        values: config.facet_attributes?.reduce<Record<string, { sortRemainingBy: 'count' }>>(\n          (sum, facet) => {\n            const facetName = typeof facet === 'string' ? facet : facet.attribute\n\n            // If request has explicit facet orders and the facet is not\n            // in the query rule actions, we don't want to sort it\n            if (\n              queryRuleActions.facetAttributesOrder &&\n              !queryRuleActions.facetAttributesOrder.includes(facetName)\n            ) {\n              return sum\n            }\n\n            return {\n              ...sum,\n              [facetName]: {\n                sortRemainingBy: 'count'\n              }\n            }\n          },\n          {}\n        )\n      }\n    }\n  }\n}\n\nconst getPageDetails = (\n  response: ElasticsearchResponseBody,\n  request: AlgoliaMultipleQueriesQuery,\n  queryRuleActions: QueryRuleActions\n) => {\n  const { params = {} } = request\n  const { hitsPerPage = 20, page = 0 } = params\n\n  const { total } = response.hits\n  const totalHits = typeof total === 'number' ? total : total?.value\n  const nbPages =\n    hitsPerPage <= 0\n      ? 0\n      : Math.ceil((typeof total === 'number' ? total : total?.value || 0) / hitsPerPage)\n\n  return {\n    hitsPerPage,\n    processingTimeMS: response.took,\n    nbHits: totalHits,\n    page: page,\n    nbPages,\n    query: queryRuleActions.query\n  }\n}\n\nexport default function transformResponse(\n  response: ElasticsearchResponseBody,\n  instantsearchRequest: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig,\n  queryRuleActions: QueryRuleActions\n) {\n  try {\n    return {\n      appliedRules: queryRuleActions.ruleIds,\n      exhaustiveNbHits: true,\n      exhaustiveFacetsCount: true,\n      exhaustiveTypo: true,\n      exhaustive: { facetsCount: true, nbHits: true, typo: true },\n      ...getPageDetails(response, instantsearchRequest, queryRuleActions),\n      ...getRenderingContent(config, queryRuleActions),\n      ...getFacets(response, config),\n      hits: getHits(response, config, instantsearchRequest),\n      index: instantsearchRequest.indexName,\n      params: new URLSearchParams(instantsearchRequest.params as any).toString(),\n      ...(queryRuleActions.userData.length > 0 ? { userData: queryRuleActions.userData } : {})\n    }\n  } catch (e) {\n    throw new Error(`Error transforming Elasticsearch response for index`)\n  }\n}\n\nexport const transformFacetValuesResponse = (\n  response: ElasticsearchResponseBody,\n  instantsearchRequest: AlgoliaMultipleQueriesQuery\n) => {\n  const aggregations = response.aggregations || {}\n  // @ts-ignore\n  const facetName = instantsearchRequest?.params?.facetName\n\n  const preTag = instantsearchRequest.params?.highlightPreTag || '<ais-highlight-0000000000>'\n  const postTag = instantsearchRequest.params?.highlightPostTag || '<ais-highlight-0000000000/>'\n\n  let agg = aggregations[Object.keys(aggregations)[0]] as any\n\n  if (agg && agg[facetName]) {\n    agg = agg[facetName]\n  }\n\n  return {\n    facetHits: agg.buckets.map((entry: any) => ({\n      value: entry.key,\n      highlighted: highlightTerm(\n        entry.key,\n        // @ts-ignore\n        instantsearchRequest.params.facetQuery || ''\n      )\n        .replace(/<\\em>/g, preTag)\n        .replace(/<\\/\\em>/g, postTag),\n      count: entry.doc_count\n    })),\n    exhaustiveFacetsCount: true,\n    processingTimeMS: response.took\n  }\n}\n","import { AppSettings, BasicAuth, ConfigConnection, SearchRequest } from './types'\nimport { ElasticsearchResponseBody, Transporter } from './types'\nimport { createElasticsearchQueryFromRequest } from './utils'\n\nconst authString = (auth: BasicAuth) => {\n  if (typeof btoa === 'undefined') {\n    return Buffer.from(auth.username + ':' + auth.password).toString('base64')\n  } else {\n    return btoa(auth.username + ':' + auth.password)\n  }\n}\n\nfunction getHostFromCloud(cloudId: string) {\n  // the cloud id is `cluster-name:base64encodedurl`\n  // the url is a string divided by two '$', the first is the cloud url\n  // the second the elasticsearch instance, the third the kibana instance\n  let cloudUrls\n  if (typeof atob === 'undefined') {\n    cloudUrls = Buffer.from(cloudId.split(':')[1], 'base64').toString()\n  } else {\n    cloudUrls = atob(cloudId.split(':')[1]).split('$')\n  }\n  return `https://${cloudUrls[1]}.${cloudUrls[0]}`\n}\n\nexport class ESTransporter implements Transporter {\n  constructor(public config: ConfigConnection, private settings: AppSettings) {}\n\n  createElasticsearchQueryFromRequest(requests: SearchRequest[]) {\n    return createElasticsearchQueryFromRequest(requests)\n  }\n\n  async performNetworkRequest(requests: SearchRequest[]) {\n    if (this.config.host === undefined && this.config.cloud_id === undefined) {\n      throw new Error(\n        'No Elasticsearch host or cloud_id specified. Please provide a host or cloud id in your Searchkit configuration.'\n      )\n    }\n\n    const host = this.config.cloud_id ? getHostFromCloud(this.config.cloud_id) : this.config.host\n\n    return fetch(`${host}/_msearch`, {\n      headers: {\n        ...(this.config.apiKey ? { authorization: `ApiKey ${this.config.apiKey}` } : {}),\n        'content-type': 'application/json',\n        ...(this.config.headers || {}),\n        ...(this.config.auth\n          ? {\n              Authorization: 'Basic ' + authString(this.config.auth)\n            }\n          : {})\n      },\n      body: this.createElasticsearchQueryFromRequest(requests),\n      method: 'POST',\n      ...(this.config.withCredentials ? { credentials: 'include' } : {})\n    })\n  }\n\n  async msearch(requests: SearchRequest[]): Promise<ElasticsearchResponseBody[]> {\n    try {\n      const response = await this.performNetworkRequest(requests)\n      const responses = await response.json()\n\n      if (this.settings.debug) {\n        console.log('Elasticsearch response:')\n        console.log(JSON.stringify(responses))\n      }\n\n      if (responses.status >= 500) {\n        console.error(\n          'Elasticsearch Internal Error: Check your elasticsearch instance to make sure it can recieve requests.'\n        )\n        throw new Error(JSON.stringify(responses))\n      } else if (responses.status === 401) {\n        console.error(\n          'Cannot connect to Elasticsearch. Check your connection host and auth details (username/password or API Key required). You can also provide a custom Elasticsearch transporter to the API Client. See https://www.searchkit.co/docs/guides/setup-elasticsearch#connecting-with-usernamepassword for more details.'\n        )\n        throw new Error(JSON.stringify(responses))\n      } else if (responses.responses?.[0]?.status === 403) {\n        console.error(\n          'Auth Error: You do not have permission to access this index. Check you are calling the right index (specified in frontend) and your API Key permissions has access to the index.'\n        )\n        throw new Error(JSON.stringify(responses))\n      } else if (responses.status === 404 || responses.responses?.[0]?.status === 404) {\n        console.error('Elasticsearch index not found. Check your index name and make sure it exists.')\n        throw new Error(JSON.stringify(responses))\n      } else if (responses.status === 400 || responses.responses?.[0]?.status === 400) {\n        console.error(\n          `Elasticsearch Bad Request.\n\n          1. Check your query and make sure it is valid.\n          2. Check the field mapping. See documentation to make sure you are using text types for searching and keyword fields for faceting\n          3. Turn on debug mode to see the Elasticsearch query and the error response.\n          `\n        )\n        throw new Error(JSON.stringify(responses))\n      }\n      return responses.responses\n    } catch (error) {\n      throw error\n    }\n  }\n}\n","import { transformQueryString } from './filters'\nimport { AlgoliaMultipleQueriesQuery, QueryRule, SearchSettingsConfig } from './types'\n\nexport interface QueryContextFilter {\n  attribute: string\n  value: string\n}\n\nexport interface QueryContext {\n  query: string\n  context: readonly string[]\n  filters: readonly QueryContextFilter[]\n}\n\nexport interface QueryRuleActions {\n  ruleIds: string[]\n  pinnedDocs: string[]\n  boostFunctions: any[]\n  query: string\n  userData: unknown[]\n  facetAttributesOrder: string[] | undefined\n  baseFilters: any[]\n  touched: boolean\n}\n\nconst getFacetFilters = (\n  facetFilters: string | readonly string[] | readonly (string | readonly string[])[] | undefined\n): QueryContextFilter[] => {\n  if (!facetFilters) {\n    return []\n  }\n  if (typeof facetFilters === 'string') {\n    const [attribute, value] = facetFilters.split(/:(.*)/)\n    return [{ attribute, value }]\n  } else {\n    // @ts-ignore\n    return facetFilters.reduce<QueryContextFilter[]>((sum: any, filter: any) => {\n      if (typeof filter === 'string') {\n        const [attribute, value] = filter.split(/:(.*)/)\n        return [...sum, { attribute, value }]\n      }\n      return [...sum, ...getFacetFilters(filter)]\n    }, [])\n  }\n}\n\nexport const getQueryRulesActionsFromRequest = (\n  queryRules: QueryRule[],\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n) => {\n  const queryContext: QueryContext = {\n    query: request.params?.query || '',\n    context: request.params?.ruleContexts || [],\n    filters: getFacetFilters(request.params?.facetFilters)\n  }\n\n  const satisfiedRules = getSatisfiedRules(queryContext, queryRules || [])\n\n  const actions = satisfiedRules.reduce<QueryRuleActions>(\n    (sum, rule) => {\n      rule.actions.map((action) => {\n        sum.touched = true\n        if (action.action === 'PinnedResult') {\n          sum.pinnedDocs.push(...action.documentIds)\n        } else if (action.action === 'QueryRewrite') {\n          sum.query = action.query\n        } else if (action.action === 'QueryBoost') {\n          sum.boostFunctions.push({\n            filter: {\n              query_string: {\n                query: transformQueryString(\n                  config.facet_attributes,\n                  config.filter_attributes,\n                  action.query\n                )\n              }\n            },\n            weight: action.weight\n          })\n        } else if (action.action === 'RenderUserData') {\n          sum.userData.push(JSON.parse(action.userData))\n        } else if (action.action === 'RenderFacetsOrder') {\n          sum.facetAttributesOrder = action.facetAttributesOrder\n        } else if (action.action === 'QueryFilter') {\n          sum.baseFilters.push({\n            query_string: {\n              query: transformQueryString(\n                config.facet_attributes,\n                config.filter_attributes,\n                action.query\n              )\n            }\n          })\n        }\n      })\n      return sum\n    },\n    {\n      ruleIds: satisfiedRules.map((rule) => rule.id),\n      pinnedDocs: [],\n      boostFunctions: [],\n      query: queryContext.query,\n      userData: [],\n      facetAttributesOrder: undefined,\n      touched: false,\n      baseFilters: []\n    }\n  )\n\n  return actions\n}\n\nexport const getSatisfiedRules = (queryContext: QueryContext, rules: QueryRule[]) =>\n  rules.filter(\n    (ruleOrs) =>\n      ruleOrs.conditions.find(\n        (rule) =>\n          rule.filter((condition) => {\n            if (condition.context === 'query' && condition.match_type === 'exact') {\n              return condition.value === queryContext.query\n            }\n            if (condition.context === 'query' && condition.match_type === 'contains') {\n              return queryContext.query.includes(condition.value)\n            }\n            if (condition.context === 'query' && condition.match_type === 'prefix') {\n              return queryContext.query.startsWith(condition.value)\n            }\n            if (condition.context === 'context') {\n              return condition.value.some((value) => queryContext.context.includes(value))\n            }\n            if (condition.context === 'filterPresent') {\n              return condition.values.every(\n                (value) =>\n                  queryContext.filters.find(\n                    (filter) => filter.attribute === value.attribute && filter.value === value.value\n                  ) !== undefined\n              )\n            }\n\n            return false\n          }).length === rule.length\n      ) !== undefined\n  )\n"],"mappings":"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","names":["require_cjs","__commonJSMin","exports","module","isMergeableObject","value","isNonNullObject","isSpecial","stringValue","isReactElement","canUseSymbol","REACT_ELEMENT_TYPE","emptyTarget","val","cloneUnlessOtherwiseSpecified","options","deepmerge","defaultArrayMerge","target","source","element","getMergeFunction","key","customMerge","getEnumerableOwnPropertySymbols","symbol","getKeys","propertyIsOnObject","object","property","propertyIsUnsafe","mergeObject","destination","sourceIsArray","targetIsArray","sourceAndTargetTypesMatch","array","prev","next","deepmerge_1","src_exports","__export","ESTransporter","MatchFilter","TermFilter","Searchkit","import_deepmerge","TermFilter","field","value","MatchFilter","getFacet","facet_attributes","attributeName","a","isNestedFacet","facet","getFacetFieldType","facet_attributes","attribute","_a","attributeKey","a","getFacetFieldConfig","createElasticsearchQueryFromRequest","requests","sum","request","transformNumericFilters","request","config","params","numericFilters","sum","filter","match","field","operator","value","maxValue","groups","facetFilterConfig","getFacetFilterMap","getFilter","esFilter","nestedPathPresent","facets","filters","f","transformFacetFilters","facetFilters","facetFilterMap","facet","filterClauseFn","TermFilter","isNestedFacet","nestedFilter","transformQueryString","queryString","regex","filterMap","word","transformBaseFilters","transformGeoFilters","aroundLatLng","aroundRadius","insideBoundingBox","insideBoundingBoxFilter","geoPoint","geoBoundingboxFilter","top","left","bottom","right","boundingBox","getSorting","request","config","selectedSorting","key","sortOption","buildSortField","sorting","fieldPath","sortConfig","getIndexName","indexName","createRegexQuery","queryString","query","char","TermAggregation","field","size","search","searchInclude","getTermAggregation","facet","aggEntries","AggregationFn","getInnerAggs","facetName","isNestedFacet","getAggs","request","config","queryRuleActions","params","type","facets","maxValuesPerFacet","facetQuery","maxFacetSize","facetAttributes","getFacet","facetAttibutes","attribute","x","facetAttribute","sum","deepmerge","queryRulesWrapper","organicQuery","RelevanceQueryMatch","search_attributes","fuzziness","getFieldsMap","boostMultiplier","getQuery","requestOptions","_a","_b","_c","searchAttributes","filters","transformFacetFilters","transformNumericFilters","transformBaseFilters","transformGeoFilters","hasKnn","hasNoQuery","queryDsl","knnQueryDsl","getHitsPerPage","getResultsSize","hitsPerPage","getHitFields","attributesToRetrieve","sourceFields","fields","getSnippetFieldLength","defaultMatch","match","getHighlightFields","attributesToHighlight","highlightFields","snippetFields","getRuntimeMappings","transformRequest","getSorting","highlightTerm","value","query","regex","match","isAllowableHighlightField","fieldKey","highlightFields","highlightField","safeHighlightField","transformObject","input","result","key","keys","currentObj","currentKey","getFieldValue","obj","path","acc","item","getHighlightFields","hit","preTag","postTag","fields","_source","highlight","combinedKeys","field","getSnippetFieldLength","hitHighlights","sum","fieldValue","highlightedMatch","singleMatch","x","getHits","response","config","instantsearchRequest","hits","highlight_attributes","snippet_attributes","hit","_a","_b","_c","_d","_e","_f","getHighlightFields","convertLatLng","value","lat","lng","v","TermFacetResponse","aggregation","sum","bucket","getFacets","aggregations","key","doc_count","nestedAggregations","f","facet","fieldType","getFacetFieldType","facetConfig","getFacetFieldConfig","facetResponse","facetValues","buckets","getRenderingContent","queryRuleActions","defaultOrder","facetName","getPageDetails","request","params","hitsPerPage","page","total","totalHits","nbPages","transformResponse","transformFacetValuesResponse","preTag","postTag","agg","entry","highlightTerm","authString","auth","getHostFromCloud","cloudId","cloudUrls","ESTransporter","config","settings","requests","createElasticsearchQueryFromRequest","host","_a","_b","_c","_d","_e","_f","responses","error","getFacetFilters","facetFilters","attribute","value","sum","filter","getQueryRulesActionsFromRequest","queryRules","request","config","_a","_b","_c","queryContext","satisfiedRules","getSatisfiedRules","rule","action","transformQueryString","rules","ruleOrs","condition","Searchkit","config","settings","ESTransporter","requests","createElasticsearchQueryFromRequest","instantsearchRequests","requestOptions","_a","_b","queryRules","requestQueryRuleActions","request","getQueryRulesActionsFromRequest","esRequests","i","transformRequest","getIndexName","esResponses","response","transformFacetValuesResponse","transformResponse","err"]}