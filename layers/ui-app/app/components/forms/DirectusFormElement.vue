<template>
    <component v-if="field && field.meta && !field.meta.hidden" :key="field.field" :is="fieldLookup"
        v-model="internalValue" :field="field.field" :width="field.meta?.width" :defaultValue="defaultValue"
        :label="label" :options="safeOptions" :required="required" :autoGenerated="internalAuto" :multiple="isMultiple" />
</template>

<script setup lang="ts">
    import type {
        DirectusField
    } from '@directus/sdk'
    import Input from './TextInput.vue'
    import TextArea from './TextArea.vue'
    import Select from './SelectInput.vue'
    import DateTime from './DateTime.vue'
    import FileInput from './FileInput.vue'
    import BooleanInput from './BooleanInput.vue'
    import RelationSelect from './RelationSelect.vue'
    import RepeaterInput from './RepeaterInput.vue'
    import TiptapEditor from './TiptapEditor.vue'

    const props = defineProps < {
        field: DirectusField
        modelValue ? : any
    } > ()

    const emit = defineEmits(['update:modelValue'])

    const internalValue = computed({
        get() {
            return props.modelValue
        },
        set(v) {
            emit('update:modelValue', v)
        }
    })

    import {
        inject,
        ref,
        computed,
        watch
    } from 'vue'

    // inject form context if parent provided it
    const formContext = inject('directusForm', null) as any

    // per-field auto-fill state
    const previousAuto = ref < string | null > (null)

    const internalAuto = computed(() => {
        return previousAuto.value != null && internalValue.value === previousAuto.value
    })

    const isAliasField = computed(() => {
        const meta = (props.field?.meta ?? {}) as any
        return (
            meta.interface === 'alias' ||
            (meta.options && (meta.options.source || meta.options.from))
        )
    })

    const slugify = (val: string) => {
        return String(val || '')
            .toLowerCase()
            .normalize('NFKD')
            .replace(/\s+/g, '-')
            .replace(/[^a-z0-9\-]/g, '')
            .replace(/-+/g, '-')
            .replace(/^-|-$/g, '')
    }

    // If this is an alias field and a form context is available, set up syncing
    if (isAliasField.value && formContext && formContext.form) {
        const meta = (props.field?.meta ?? {}) as any
        let sourceField: string | null = meta?.options?.source ?? meta?.options?.from ?? null

        if (!sourceField && formContext.fields) {
            const candidates = ['name', 'title']
            sourceField = candidates.find((c: string) => formContext.fields.value.some((f: any) => f.field === c)) ??
                null
        }

        if (sourceField) {
            watch(
                () => formContext.form.value?.[sourceField as string],
                (newVal) => {
                    try {
                        const target = props.field.field
                        const current = formContext.form.value?.[target] ?? ''
                        const generated = slugify(String(newVal ?? ''))
                        if (!generated) return
                        if (!current || current === previousAuto.value) {
                            // update shared form state and emit update for parent v-model
                            if (formContext.form && formContext.form.value) {
                                formContext.form.value[target] = generated
                            }
                            internalValue.value = generated
                            previousAuto.value = generated
                        }
                    } catch (e) {
                        // ignore
                    }
                }, {
                    immediate: true
                }
            )
        }
    }

    const fieldLookup = computed(() => {
        const iface = props.field?.meta?.interface
        // normalize iface to lower-case for comparisons
        const name = String(iface ?? '').toLowerCase()

        // handle simple text inputs and variants
        if (['input', 'string'].includes(name)) return Input
        // rich text / wysiwyg - use TipTap editor when available
        if (['input-rich-text-md', 'input-rich-text', 'input-rich-text-html', 'input-rich-text-md', 'text', 'input-multiline', 'textarea', 'wysiwyg', 'rich-text'].includes(name)) return TiptapEditor

        // select & choices
        if (['select-dropdown', 'select', 'select-multiple', 'dropdown'].includes(name)) return Select

        if (name === 'datetime') return DateTime

        if (['file', 'files', 'file-image', 'file-thumbnail', 'one-to-one-file', 'files-many'].includes(name)) return FileInput

        if (name === 'boolean') return BooleanInput

        // repeater / json
        try {
            const schemaAny = (props.field?.schema ?? {}) as any
            const schemaType = schemaAny?.type ?? schemaAny?.data_type ?? null
            if (name === 'repeater' || schemaType === 'json') return RepeaterInput
        } catch (e) {
            // ignore and continue
        }

        // relation interfaces - use RelationSelect which will fetch related collection items
        if (name.includes('many') || name.includes('one') || name.includes('to')) {
            // best-effort mapping: return relation select for many/one relation interfaces
            return RelationSelect
        }

        // fallback to simple input
        return Input
    })

    const required = computed(() => {
        // Directus may put required information in different places; normalize to a boolean
        try {
            const meta = props.field?.meta as any
            // common locations: meta.validation.required, meta.required
            return Boolean((meta && (meta.validation?.required ?? meta.required)) || false)
        } catch (e) {
            return false
        }
    })

    const safeOptions = computed(() => props.field?.meta?.options ?? null)

    const label = computed(() => props.field?.meta?.field ?? props.field?.field ?? '')

    const defaultValue = computed(() => props.field?.schema?.default_value ?? null)
    const isMultiple = computed(() => {
        try {
            const name = String(props.field?.meta?.interface ?? '').toLowerCase()
            if (name === 'select-multiple') return true
            if (name.includes('many')) return true
            const opts = (props.field?.meta ?? {}) as any
            return Boolean(opts?.options?.multiple || false)
        } catch (e) {
            return false
        }
    })
</script>