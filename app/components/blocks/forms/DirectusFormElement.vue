<template>
    <component v-if="field && field.meta && !field.meta.hidden" :key="field.field" :is="fieldLookup"
        v-model="internalValue" :field="field.field" :width="field.meta?.width" :defaultValue="defaultValue"
        :label="label" :options="safeOptions" :required="required" :autoGenerated="internalAuto" />
</template>

<script setup lang="ts">
    import type {
        DirectusField
    } from '@directus/sdk'
    import Input from './TextInput.vue'
    import TextArea from './TextArea.vue'
    import Select from './SelectInput.vue'
    import DateTime from './DateTime.vue'
    import FileInput from './FileInput.vue'
    import BooleanInput from './BooleanInput.vue'

    const props = defineProps < {
        field: DirectusField
        modelValue ? : any
    } > ()

    const emit = defineEmits(['update:modelValue'])

    const internalValue = computed({
        get() {
            return props.modelValue
        },
        set(v) {
            emit('update:modelValue', v)
        }
    })

    import {
        inject,
        ref,
        computed,
        watch
    } from 'vue'

    // inject form context if parent provided it
    const formContext = inject('directusForm', null) as any

    // per-field auto-fill state
    const previousAuto = ref < string | null > (null)

    const internalAuto = computed(() => {
        return previousAuto.value != null && internalValue.value === previousAuto.value
    })

    const isAliasField = computed(() => {
        const meta = (props.field?.meta ?? {}) as any
        return (
            meta.interface === 'alias' ||
            (meta.options && (meta.options.source || meta.options.from))
        )
    })

    const slugify = (val: string) => {
        return String(val || '')
            .toLowerCase()
            .normalize('NFKD')
            .replace(/\s+/g, '-')
            .replace(/[^a-z0-9\-]/g, '')
            .replace(/-+/g, '-')
            .replace(/^-|-$/g, '')
    }

    // If this is an alias field and a form context is available, set up syncing
    if (isAliasField.value && formContext && formContext.form) {
        const meta = (props.field?.meta ?? {}) as any
        let sourceField: string | null = meta?.options?.source ?? meta?.options?.from ?? null

        if (!sourceField && formContext.fields) {
            const candidates = ['name', 'title']
            sourceField = candidates.find((c: string) => formContext.fields.value.some((f: any) => f.field === c)) ??
                null
        }

        if (sourceField) {
            watch(
                () => formContext.form.value?.[sourceField as string],
                (newVal) => {
                    try {
                        const target = props.field.field
                        const current = formContext.form.value?.[target] ?? ''
                        const generated = slugify(String(newVal ?? ''))
                        if (!generated) return
                        if (!current || current === previousAuto.value) {
                            // update shared form state and emit update for parent v-model
                            if (formContext.form && formContext.form.value) {
                                formContext.form.value[target] = generated
                            }
                            internalValue.value = generated
                            previousAuto.value = generated
                        }
                    } catch (e) {
                        // ignore
                    }
                }, {
                    immediate: true
                }
            )
        }
    }

    const fieldLookup = computed(() => {
        const iface = props.field?.meta?.interface
        switch (iface) {
            case 'input':
            case 'string':
                return Input

            case 'input-rich-text-md':
            case 'text':
            case 'input-multiline':
            case 'textarea':
                return TextArea

            case 'select-dropdown':
                return Select

            case 'datetime':
                return DateTime

            case 'file':
            case 'files':
            case 'file-image':
            case 'file-thumbnail':
            case 'one-to-one-file':
            case 'files-many':
                return FileInput

                return FileInput

            case 'boolean':
                return BooleanInput

            default:
                return Input
        }
    })

    const required = computed(() => {
        // Directus may put required information in different places; normalize to a boolean
        try {
            const meta = props.field?.meta as any
            // common locations: meta.validation.required, meta.required
            return Boolean((meta && (meta.validation?.required ?? meta.required)) || false)
        } catch (e) {
            return false
        }
    })

    const safeOptions = computed(() => props.field?.meta?.options ?? null)

    const label = computed(() => props.field?.meta?.field ?? props.field?.field ?? '')

    const defaultValue = computed(() => props.field?.schema?.default_value ?? null)
</script>